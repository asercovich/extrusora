CCS PCH C Compiler, Version 5.015, 5967               10-ago-19 07:27

               Filename:   C:\Users\Agustin\Desktop\Cables nuevo\2-Equipamiento\Extrusora\ELECTRONICA SEGUNDO\Soft Pic\Diego nuevo\TERCERO INT en uso\18F4550.lst

               ROM used:   11188 bytes (34%)
                           Largest free fragment is 21576
               RAM used:   128 (6%) at main() level
                           182 (9%) worst case
               Stack used: 12 locations (8 in main + 4 for interrupts)
               Stack size: 31

*
0000:  GOTO   28A6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   09AE
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0096:  MOVFF  FF2,0D
009A:  BCF    FF2.7
009C:  CLRF   FF7
009E:  ADDLW  B0
00A0:  MOVWF  FF6
00A2:  MOVLW  00
00A4:  ADDWFC FF7,F
00A6:  TBLRD*+
00A8:  MOVF   FF5,W
00AA:  BTFSC  0D.7
00AC:  BSF    FF2.7
00AE:  RETURN 0
00B0:  DATA 28,0C
00B2:  DATA 01,06
00B4:  DATA 0C,00
00B6:  DATA 20,20
00B8:  DATA 4D,4F
00BA:  DATA 44,4F
00BC:  DATA 20,50
00BE:  DATA 52,4F
00C0:  DATA 47,52
00C2:  DATA 41,4D
00C4:  DATA 41,43
00C6:  DATA 49,4F
00C8:  DATA 4E,20
00CA:  DATA 00,00
00CC:  DATA 20,20
00CE:  DATA 20,20
00D0:  DATA 20,20
00D2:  DATA 20,20
00D4:  DATA 20,20
00D6:  DATA 20,20
00D8:  DATA 20,20
00DA:  DATA 20,20
00DC:  DATA 20,20
00DE:  DATA 20,20
00E0:  DATA 20,00
00E2:  DATA 20,20
00E4:  DATA 20,00
00E6:  DATA 20,20
00E8:  DATA 20,00
00EA:  DATA 20,20
00EC:  DATA 20,00
00EE:  DATA 20,20
00F0:  DATA 20,00
00F2:  DATA 5A,31
00F4:  DATA 3A,00
00F6:  DATA 5A,32
00F8:  DATA 3A,00
00FA:  DATA 5A,33
00FC:  DATA 3A,00
00FE:  DATA 5A,34
0100:  DATA 3A,00
0102:  DATA 20,20
0104:  DATA 20,20
0106:  DATA 20,20
0108:  DATA 20,00
010A:  DATA 20,20
010C:  DATA 20,20
010E:  DATA 20,20
0110:  DATA 20,00
0112:  DATA 20,20
0114:  DATA 20,20
0116:  DATA 20,20
0118:  DATA 20,00
011A:  DATA 20,20
011C:  DATA 20,20
011E:  DATA 20,20
0120:  DATA 20,00
0122:  DATA 20,20
0124:  DATA 20,00
0126:  DATA 20,20
0128:  DATA 20,00
012A:  DATA 54,5F
012C:  DATA 41,4D
012E:  DATA 42,3A
0130:  DATA 00,00
0132:  DATA 54,5F
0134:  DATA 4D,4F
0136:  DATA 54,3A
0138:  DATA 00,00
013A:  DATA 49,5F
013C:  DATA 4D,4F
013E:  DATA 54,3A
0140:  DATA 00,00
0142:  DATA 52,50
0144:  DATA 4D,20
0146:  DATA 3A,00
0148:  DATA 20,20
014A:  DATA 20,20
014C:  DATA 00,00
014E:  DATA 20,20
0150:  DATA 20,20
0152:  DATA 00,00
0154:  DATA 20,20
0156:  DATA 20,20
0158:  DATA 00,00
015A:  DATA 20,20
015C:  DATA 20,20
015E:  DATA 00,00
0160:  DATA 4F,66
0162:  DATA 5A,31
0164:  DATA 3A,00
0166:  DATA 4F,66
0168:  DATA 5A,32
016A:  DATA 3A,00
016C:  DATA 4F,66
016E:  DATA 5A,33
0170:  DATA 3A,00
0172:  DATA 4F,66
0174:  DATA 5A,34
0176:  DATA 3A,00
0178:  DATA 4D,61
017A:  DATA 78,5A
017C:  DATA 31,3A
017E:  DATA 00,00
0180:  DATA 4D,61
0182:  DATA 78,5A
0184:  DATA 32,3A
0186:  DATA 00,00
0188:  DATA 4D,61
018A:  DATA 78,5A
018C:  DATA 33,3A
018E:  DATA 00,00
0190:  DATA 4D,61
0192:  DATA 78,5A
0194:  DATA 34,3A
0196:  DATA 00,00
0198:  DATA 20,20
019A:  DATA 20,20
019C:  DATA 00,00
019E:  DATA 20,20
01A0:  DATA 20,20
01A2:  DATA 00,00
01A4:  DATA 20,20
01A6:  DATA 20,20
01A8:  DATA 00,00
01AA:  DATA 20,20
01AC:  DATA 20,20
01AE:  DATA 00,00
01B0:  DATA 20,20
01B2:  DATA 20,20
01B4:  DATA 00,00
01B6:  DATA 20,20
01B8:  DATA 20,20
01BA:  DATA 00,00
01BC:  DATA 20,20
01BE:  DATA 20,20
01C0:  DATA 00,00
01C2:  DATA 20,20
01C4:  DATA 20,20
01C6:  DATA 00,00
01C8:  DATA 4F,66
01CA:  DATA 4D,6F
01CC:  DATA 74,3A
01CE:  DATA 00,00
01D0:  DATA 4F,66
01D2:  DATA 41,6D
01D4:  DATA 62,3A
01D6:  DATA 00,00
01D8:  DATA 4D,61
01DA:  DATA 78,4D
01DC:  DATA 3A,00
01DE:  DATA 4D,61
01E0:  DATA 78,41
01E2:  DATA 3A,00
01E4:  DATA 20,20
01E6:  DATA 20,20
01E8:  DATA 00,00
01EA:  DATA 20,20
01EC:  DATA 20,20
01EE:  DATA 00,00
01F0:  DATA 20,20
01F2:  DATA 20,20
01F4:  DATA 00,00
01F6:  DATA 20,20
01F8:  DATA 20,20
01FA:  DATA 00,00
01FC:  DATA 0C,00
01FE:  DATA 0C,00
0200:  DATA 44,61
0202:  DATA 74,6F
0204:  DATA 73,20
0206:  DATA 47,75
0208:  DATA 61,72
020A:  DATA 64,61
020C:  DATA 64,6F
020E:  DATA 73,00
0210:  DATA 0C,00
*
0342:  MOVLW  8E
0344:  MOVWF  00
0346:  MOVFF  A7,01
034A:  MOVFF  A6,02
034E:  CLRF   03
0350:  MOVF   01,F
0352:  BNZ   0366
0354:  MOVFF  02,01
0358:  CLRF   02
035A:  MOVLW  08
035C:  SUBWF  00,F
035E:  MOVF   01,F
0360:  BNZ   0366
0362:  CLRF   00
0364:  BRA    0376
0366:  BCF    FD8.0
0368:  BTFSC  01.7
036A:  BRA    0374
036C:  RLCF   02,F
036E:  RLCF   01,F
0370:  DECF   00,F
0372:  BRA    0366
0374:  BCF    01.7
0376:  RETURN 0
0378:  MOVF   xA6,W
037A:  BTFSC  FD8.2
037C:  BRA    0460
037E:  MOVWF  00
0380:  MOVF   xAA,W
0382:  BTFSC  FD8.2
0384:  BRA    0460
0386:  ADDWF  00,F
0388:  BNC   0392
038A:  MOVLW  81
038C:  ADDWF  00,F
038E:  BC    0460
0390:  BRA    039A
0392:  MOVLW  7F
0394:  SUBWF  00,F
0396:  BNC   0460
0398:  BZ    0460
039A:  MOVFF  A7,AE
039E:  MOVF   xAB,W
03A0:  XORWF  xAE,F
03A2:  BSF    xA7.7
03A4:  BSF    xAB.7
03A6:  MOVF   xA9,W
03A8:  MULWF  xAD
03AA:  MOVFF  FF4,B0
03AE:  MOVF   xA8,W
03B0:  MULWF  xAC
03B2:  MOVFF  FF4,03
03B6:  MOVFF  FF3,AF
03BA:  MULWF  xAD
03BC:  MOVF   FF3,W
03BE:  ADDWF  xB0,F
03C0:  MOVF   FF4,W
03C2:  ADDWFC xAF,F
03C4:  MOVLW  00
03C6:  ADDWFC 03,F
03C8:  MOVF   xA9,W
03CA:  MULWF  xAC
03CC:  MOVF   FF3,W
03CE:  ADDWF  xB0,F
03D0:  MOVF   FF4,W
03D2:  ADDWFC xAF,F
03D4:  MOVLW  00
03D6:  CLRF   02
03D8:  ADDWFC 03,F
03DA:  ADDWFC 02,F
03DC:  MOVF   xA7,W
03DE:  MULWF  xAD
03E0:  MOVF   FF3,W
03E2:  ADDWF  xAF,F
03E4:  MOVF   FF4,W
03E6:  ADDWFC 03,F
03E8:  MOVLW  00
03EA:  ADDWFC 02,F
03EC:  MOVF   xA7,W
03EE:  MULWF  xAC
03F0:  MOVF   FF3,W
03F2:  ADDWF  03,F
03F4:  MOVF   FF4,W
03F6:  ADDWFC 02,F
03F8:  MOVLW  00
03FA:  CLRF   01
03FC:  ADDWFC 01,F
03FE:  MOVF   xA9,W
0400:  MULWF  xAB
0402:  MOVF   FF3,W
0404:  ADDWF  xAF,F
0406:  MOVF   FF4,W
0408:  ADDWFC 03,F
040A:  MOVLW  00
040C:  ADDWFC 02,F
040E:  ADDWFC 01,F
0410:  MOVF   xA8,W
0412:  MULWF  xAB
0414:  MOVF   FF3,W
0416:  ADDWF  03,F
0418:  MOVF   FF4,W
041A:  ADDWFC 02,F
041C:  MOVLW  00
041E:  ADDWFC 01,F
0420:  MOVF   xA7,W
0422:  MULWF  xAB
0424:  MOVF   FF3,W
0426:  ADDWF  02,F
0428:  MOVF   FF4,W
042A:  ADDWFC 01,F
042C:  INCF   00,F
042E:  BTFSC  01.7
0430:  BRA    043C
0432:  RLCF   xAF,F
0434:  RLCF   03,F
0436:  RLCF   02,F
0438:  RLCF   01,F
043A:  DECF   00,F
043C:  MOVLW  00
043E:  BTFSS  xAF.7
0440:  BRA    0456
0442:  INCF   03,F
0444:  ADDWFC 02,F
0446:  ADDWFC 01,F
0448:  MOVF   01,W
044A:  BNZ   0456
044C:  MOVF   02,W
044E:  BNZ   0456
0450:  MOVF   03,W
0452:  BNZ   0456
0454:  INCF   00,F
0456:  BTFSC  xAE.7
0458:  BSF    01.7
045A:  BTFSS  xAE.7
045C:  BCF    01.7
045E:  BRA    0468
0460:  CLRF   00
0462:  CLRF   01
0464:  CLRF   02
0466:  CLRF   03
0468:  RETURN 0
046A:  MOVLW  80
046C:  BTFSC  FD8.1
046E:  XORWF  xAB,F
0470:  CLRF   xB0
0472:  CLRF   xB1
0474:  MOVFF  A7,AF
0478:  MOVF   xAB,W
047A:  XORWF  xAF,F
047C:  MOVF   xA6,W
047E:  BTFSC  FD8.2
0480:  BRA    063A
0482:  MOVWF  xAE
0484:  MOVWF  00
0486:  MOVF   xAA,W
0488:  BTFSC  FD8.2
048A:  BRA    064C
048C:  SUBWF  xAE,F
048E:  BTFSC  FD8.2
0490:  BRA    0594
0492:  BNC   050E
0494:  MOVFF  AB,B4
0498:  BSF    xB4.7
049A:  MOVFF  AC,B3
049E:  MOVFF  AD,B2
04A2:  CLRF   xB1
04A4:  BCF    FD8.0
04A6:  RRCF   xB4,F
04A8:  RRCF   xB3,F
04AA:  RRCF   xB2,F
04AC:  RRCF   xB1,F
04AE:  DECFSZ xAE,F
04B0:  BRA    04A2
04B2:  BTFSS  xAF.7
04B4:  BRA    04BC
04B6:  BSF    xB0.0
04B8:  BRA    0674
04BA:  BCF    xB0.0
04BC:  BCF    xAE.0
04BE:  BSF    xB0.4
04C0:  CLRF   FEA
04C2:  MOVLW  A9
04C4:  MOVWF  FE9
04C6:  BRA    069A
04C8:  BCF    xB0.4
04CA:  BTFSC  xAF.7
04CC:  BRA    04E2
04CE:  BTFSS  xAE.0
04D0:  BRA    04F8
04D2:  RRCF   xB4,F
04D4:  RRCF   xB3,F
04D6:  RRCF   xB2,F
04D8:  RRCF   xB1,F
04DA:  INCF   00,F
04DC:  BTFSC  FD8.2
04DE:  BRA    066A
04E0:  BRA    04F8
04E2:  BTFSC  xB4.7
04E4:  BRA    04FE
04E6:  BCF    FD8.0
04E8:  RLCF   xB1,F
04EA:  RLCF   xB2,F
04EC:  RLCF   xB3,F
04EE:  RLCF   xB4,F
04F0:  DECF   00,F
04F2:  BTFSC  FD8.2
04F4:  BRA    066A
04F6:  BRA    04E2
04F8:  BSF    xB0.6
04FA:  BRA    05D2
04FC:  BCF    xB0.6
04FE:  MOVFF  A7,AF
0502:  BTFSS  xA7.7
0504:  BRA    050A
0506:  BSF    xB4.7
0508:  BRA    065C
050A:  BCF    xB4.7
050C:  BRA    065C
050E:  MOVFF  AA,AE
0512:  MOVFF  AA,00
0516:  MOVF   xA6,W
0518:  SUBWF  xAE,F
051A:  MOVFF  A7,B4
051E:  BSF    xB4.7
0520:  MOVFF  A8,B3
0524:  MOVFF  A9,B2
0528:  CLRF   xB1
052A:  BCF    FD8.0
052C:  RRCF   xB4,F
052E:  RRCF   xB3,F
0530:  RRCF   xB2,F
0532:  RRCF   xB1,F
0534:  DECFSZ xAE,F
0536:  BRA    0528
0538:  BTFSS  xAF.7
053A:  BRA    0542
053C:  BSF    xB0.1
053E:  BRA    0674
0540:  BCF    xB0.1
0542:  BCF    xAE.0
0544:  BSF    xB0.5
0546:  CLRF   FEA
0548:  MOVLW  AD
054A:  MOVWF  FE9
054C:  BRA    069A
054E:  BCF    xB0.5
0550:  BTFSC  xAF.7
0552:  BRA    0568
0554:  BTFSS  xAE.0
0556:  BRA    057E
0558:  RRCF   xB4,F
055A:  RRCF   xB3,F
055C:  RRCF   xB2,F
055E:  RRCF   xB1,F
0560:  INCF   00,F
0562:  BTFSC  FD8.2
0564:  BRA    066A
0566:  BRA    057E
0568:  BTFSC  xB4.7
056A:  BRA    0584
056C:  BCF    FD8.0
056E:  RLCF   xB1,F
0570:  RLCF   xB2,F
0572:  RLCF   xB3,F
0574:  RLCF   xB4,F
0576:  DECF   00,F
0578:  BTFSC  FD8.2
057A:  BRA    066A
057C:  BRA    0568
057E:  BSF    xB0.7
0580:  BRA    05D2
0582:  BCF    xB0.7
0584:  MOVFF  AB,AF
0588:  BTFSS  xAB.7
058A:  BRA    0590
058C:  BSF    xB4.7
058E:  BRA    065C
0590:  BCF    xB4.7
0592:  BRA    065C
0594:  MOVFF  AB,B4
0598:  BSF    xB4.7
059A:  MOVFF  AC,B3
059E:  MOVFF  AD,B2
05A2:  BTFSS  xAF.7
05A4:  BRA    05AE
05A6:  BCF    xB4.7
05A8:  BSF    xB0.2
05AA:  BRA    0674
05AC:  BCF    xB0.2
05AE:  CLRF   xB1
05B0:  BCF    xAE.0
05B2:  CLRF   FEA
05B4:  MOVLW  A9
05B6:  MOVWF  FE9
05B8:  BRA    069A
05BA:  BTFSC  xAF.7
05BC:  BRA    05F6
05BE:  MOVFF  A7,AF
05C2:  BTFSS  xAE.0
05C4:  BRA    05D2
05C6:  RRCF   xB4,F
05C8:  RRCF   xB3,F
05CA:  RRCF   xB2,F
05CC:  RRCF   xB1,F
05CE:  INCF   00,F
05D0:  BZ    066A
05D2:  BTFSS  xB1.7
05D4:  BRA    05EC
05D6:  INCF   xB2,F
05D8:  BNZ   05EC
05DA:  INCF   xB3,F
05DC:  BNZ   05EC
05DE:  INCF   xB4,F
05E0:  BNZ   05EC
05E2:  RRCF   xB4,F
05E4:  RRCF   xB3,F
05E6:  RRCF   xB2,F
05E8:  INCF   00,F
05EA:  BZ    066A
05EC:  BTFSC  xB0.6
05EE:  BRA    04FC
05F0:  BTFSC  xB0.7
05F2:  BRA    0582
05F4:  BRA    062E
05F6:  MOVLW  80
05F8:  XORWF  xB4,F
05FA:  BTFSS  xB4.7
05FC:  BRA    0606
05FE:  BRA    0674
0600:  MOVFF  AB,AF
0604:  BRA    061A
0606:  MOVFF  A7,AF
060A:  MOVF   xB4,F
060C:  BNZ   061A
060E:  MOVF   xB3,F
0610:  BNZ   061A
0612:  MOVF   xB2,F
0614:  BNZ   061A
0616:  CLRF   00
0618:  BRA    065C
061A:  BTFSC  xB4.7
061C:  BRA    062E
061E:  BCF    FD8.0
0620:  RLCF   xB1,F
0622:  RLCF   xB2,F
0624:  RLCF   xB3,F
0626:  RLCF   xB4,F
0628:  DECFSZ 00,F
062A:  BRA    061A
062C:  BRA    066A
062E:  BTFSS  xAF.7
0630:  BRA    0636
0632:  BSF    xB4.7
0634:  BRA    065C
0636:  BCF    xB4.7
0638:  BRA    065C
063A:  MOVFF  AA,00
063E:  MOVFF  AB,B4
0642:  MOVFF  AC,B3
0646:  MOVFF  AD,B2
064A:  BRA    065C
064C:  MOVFF  A6,00
0650:  MOVFF  A7,B4
0654:  MOVFF  A8,B3
0658:  MOVFF  A9,B2
065C:  MOVFF  B4,01
0660:  MOVFF  B3,02
0664:  MOVFF  B2,03
0668:  BRA    06D2
066A:  CLRF   00
066C:  CLRF   01
066E:  CLRF   02
0670:  CLRF   03
0672:  BRA    06D2
0674:  CLRF   xB1
0676:  COMF   xB2,F
0678:  COMF   xB3,F
067A:  COMF   xB4,F
067C:  COMF   xB1,F
067E:  INCF   xB1,F
0680:  BNZ   068C
0682:  INCF   xB2,F
0684:  BNZ   068C
0686:  INCF   xB3,F
0688:  BNZ   068C
068A:  INCF   xB4,F
068C:  BTFSC  xB0.0
068E:  BRA    04BA
0690:  BTFSC  xB0.1
0692:  BRA    0540
0694:  BTFSC  xB0.2
0696:  BRA    05AC
0698:  BRA    0600
069A:  MOVF   FEF,W
069C:  ADDWF  xB2,F
069E:  BNC   06AA
06A0:  INCF   xB3,F
06A2:  BNZ   06AA
06A4:  INCF   xB4,F
06A6:  BTFSC  FD8.2
06A8:  BSF    xAE.0
06AA:  MOVF   FED,F
06AC:  MOVF   FEF,W
06AE:  ADDWF  xB3,F
06B0:  BNC   06B8
06B2:  INCF   xB4,F
06B4:  BTFSC  FD8.2
06B6:  BSF    xAE.0
06B8:  MOVF   FED,F
06BA:  MOVF   FEF,W
06BC:  BTFSC  FEF.7
06BE:  BRA    06C2
06C0:  XORLW  80
06C2:  ADDWF  xB4,F
06C4:  BTFSC  FD8.0
06C6:  BSF    xAE.0
06C8:  BTFSC  xB0.4
06CA:  BRA    04C8
06CC:  BTFSC  xB0.5
06CE:  BRA    054E
06D0:  BRA    05BA
06D2:  RETURN 0
*
07C4:  MOVFF  A0,A7
07C8:  MOVF   xA4,W
07CA:  XORWF  xA7,F
07CC:  BTFSS  xA7.7
07CE:  BRA    07DA
07D0:  BCF    FD8.2
07D2:  BCF    FD8.0
07D4:  BTFSC  xA0.7
07D6:  BSF    FD8.0
07D8:  BRA    0838
07DA:  MOVFF  A0,A7
07DE:  MOVFF  A3,A8
07E2:  MOVF   x9F,W
07E4:  SUBWF  xA8,F
07E6:  BZ    07F4
07E8:  BTFSS  xA7.7
07EA:  BRA    0838
07EC:  MOVF   FD8,W
07EE:  XORLW  01
07F0:  MOVWF  FD8
07F2:  BRA    0838
07F4:  MOVFF  A4,A8
07F8:  MOVF   xA0,W
07FA:  SUBWF  xA8,F
07FC:  BZ    080A
07FE:  BTFSS  xA7.7
0800:  BRA    0838
0802:  MOVF   FD8,W
0804:  XORLW  01
0806:  MOVWF  FD8
0808:  BRA    0838
080A:  MOVFF  A5,A8
080E:  MOVF   xA1,W
0810:  SUBWF  xA8,F
0812:  BZ    0820
0814:  BTFSS  xA7.7
0816:  BRA    0838
0818:  MOVF   FD8,W
081A:  XORLW  01
081C:  MOVWF  FD8
081E:  BRA    0838
0820:  MOVFF  A6,A8
0824:  MOVF   xA2,W
0826:  SUBWF  xA8,F
0828:  BZ    0836
082A:  BTFSS  xA7.7
082C:  BRA    0838
082E:  MOVF   FD8,W
0830:  XORLW  01
0832:  MOVWF  FD8
0834:  BRA    0838
0836:  BCF    FD8.0
0838:  RETURN 0
*
09E4:  DATA 48,32
09E6:  DATA 2D,54
09E8:  DATA 65,63
09EA:  DATA 00,00
09EC:  DATA 53,69
09EE:  DATA 73,74
09F0:  DATA 65,6D
09F2:  DATA 61,20
09F4:  DATA 64,65
09F6:  DATA 20,65
09F8:  DATA 78,74
09FA:  DATA 72,75
09FC:  DATA 73,69
09FE:  DATA 6F,6E
0A00:  DATA 00,00
0A02:  DATA 56,65
0A04:  DATA 72,73
0A06:  DATA 69,6F
0A08:  DATA 6E,20
0A0A:  DATA 31,2E
0A0C:  DATA 30,00
0A0E:  DATA 0C,00
0A10:  DATA 0C,00
0A12:  DATA 4D,4F
0A14:  DATA 44,4F
0A16:  DATA 20,50
0A18:  DATA 52,4F
0A1A:  DATA 47,52
0A1C:  DATA 41,4D
0A1E:  DATA 41,43
0A20:  DATA 49,4F
0A22:  DATA 4E,00
0A24:  DATA 0C,00
*
0CA4:  TBLRD*+
0CA6:  MOVF   FF5,F
0CA8:  BZ    0CC2
0CAA:  MOVFF  FF6,83
0CAE:  MOVFF  FF7,84
0CB2:  MOVFF  FF5,8F
0CB6:  RCALL  0C5C
0CB8:  MOVFF  83,FF6
0CBC:  MOVFF  84,FF7
0CC0:  BRA    0CA4
0CC2:  RETURN 0
*
0D5C:  MOVFF  FEA,8A
0D60:  MOVFF  FE9,89
0D64:  SWAPF  x83,W
0D66:  IORLW  F0
0D68:  MOVWF  x85
0D6A:  ADDWF  x85,F
0D6C:  ADDLW  E2
0D6E:  MOVWF  x86
0D70:  ADDLW  32
0D72:  MOVWF  x88
0D74:  MOVF   x83,W
0D76:  ANDLW  0F
0D78:  ADDWF  x86,F
0D7A:  ADDWF  x86,F
0D7C:  ADDWF  x88,F
0D7E:  ADDLW  E9
0D80:  MOVWF  x87
0D82:  ADDWF  x87,F
0D84:  ADDWF  x87,F
0D86:  SWAPF  x82,W
0D88:  ANDLW  0F
0D8A:  ADDWF  x87,F
0D8C:  ADDWF  x88,F
0D8E:  RLCF   x87,F
0D90:  RLCF   x88,F
0D92:  COMF   x88,F
0D94:  RLCF   x88,F
0D96:  MOVF   x82,W
0D98:  ANDLW  0F
0D9A:  ADDWF  x88,F
0D9C:  RLCF   x85,F
0D9E:  MOVLW  07
0DA0:  MOVWF  x84
0DA2:  MOVLW  0A
0DA4:  DECF   x87,F
0DA6:  ADDWF  x88,F
0DA8:  BNC   0DA4
0DAA:  DECF   x86,F
0DAC:  ADDWF  x87,F
0DAE:  BNC   0DAA
0DB0:  DECF   x85,F
0DB2:  ADDWF  x86,F
0DB4:  BNC   0DB0
0DB6:  DECF   x84,F
0DB8:  ADDWF  x85,F
0DBA:  BNC   0DB6
0DBC:  CLRF   FEA
0DBE:  MOVLW  84
0DC0:  MOVWF  FE9
0DC2:  MOVLW  07
0DC4:  ANDWF  x89,W
0DC6:  BCF    x89.6
0DC8:  ADDWF  FE9,F
0DCA:  MOVLW  00
0DCC:  ADDWFC FEA,F
0DCE:  MOVF   FE9,W
0DD0:  SUBLW  88
0DD2:  BNZ   0DDA
0DD4:  MOVF   FEA,F
0DD6:  BNZ   0DDA
0DD8:  BSF    x89.6
0DDA:  MOVF   FEF,W
0DDC:  MOVWF  00
0DDE:  BNZ   0DF0
0DE0:  BTFSC  x89.6
0DE2:  BRA    0DF0
0DE4:  BTFSC  x89.4
0DE6:  BRA    0E0E
0DE8:  BTFSC  x89.3
0DEA:  BRA    0DF0
0DEC:  MOVLW  20
0DEE:  BRA    0DF6
0DF0:  BSF    x89.3
0DF2:  BCF    x89.4
0DF4:  MOVLW  30
0DF6:  ADDWF  00,F
0DF8:  MOVFF  FEA,83
0DFC:  MOVFF  FE9,82
0E00:  MOVFF  00,8F
0E04:  RCALL  0C5C
0E06:  MOVFF  83,FEA
0E0A:  MOVFF  82,FE9
0E0E:  MOVF   FEE,W
0E10:  BTFSS  x89.6
0E12:  BRA    0DCE
0E14:  RETURN 0
0E16:  MOVF   x8F,W
0E18:  SUBLW  B6
0E1A:  MOVWF  x8F
0E1C:  CLRF   03
0E1E:  MOVFF  90,93
0E22:  BSF    x90.7
0E24:  BCF    FD8.0
0E26:  RRCF   x90,F
0E28:  RRCF   x91,F
0E2A:  RRCF   x92,F
0E2C:  RRCF   03,F
0E2E:  RRCF   02,F
0E30:  RRCF   01,F
0E32:  RRCF   00,F
0E34:  DECFSZ x8F,F
0E36:  BRA    0E24
0E38:  BTFSS  x93.7
0E3A:  BRA    0E52
0E3C:  COMF   00,F
0E3E:  COMF   01,F
0E40:  COMF   02,F
0E42:  COMF   03,F
0E44:  INCF   00,F
0E46:  BTFSC  FD8.2
0E48:  INCF   01,F
0E4A:  BTFSC  FD8.2
0E4C:  INCF   02,F
0E4E:  BTFSC  FD8.2
0E50:  INCF   03,F
0E52:  GOTO   0F8E (RETURN)
0E56:  BTFSC  FD8.1
0E58:  BRA    0E60
0E5A:  CLRF   FEA
0E5C:  MOVLW  97
0E5E:  MOVWF  FE9
0E60:  CLRF   00
0E62:  CLRF   01
0E64:  CLRF   02
0E66:  CLRF   03
0E68:  CLRF   x97
0E6A:  CLRF   x98
0E6C:  CLRF   x99
0E6E:  CLRF   x9A
0E70:  MOVF   x96,W
0E72:  IORWF  x95,W
0E74:  IORWF  x94,W
0E76:  IORWF  x93,W
0E78:  BZ    0ED2
0E7A:  MOVLW  20
0E7C:  MOVWF  x9B
0E7E:  BCF    FD8.0
0E80:  RLCF   x8F,F
0E82:  RLCF   x90,F
0E84:  RLCF   x91,F
0E86:  RLCF   x92,F
0E88:  RLCF   x97,F
0E8A:  RLCF   x98,F
0E8C:  RLCF   x99,F
0E8E:  RLCF   x9A,F
0E90:  MOVF   x96,W
0E92:  SUBWF  x9A,W
0E94:  BNZ   0EA6
0E96:  MOVF   x95,W
0E98:  SUBWF  x99,W
0E9A:  BNZ   0EA6
0E9C:  MOVF   x94,W
0E9E:  SUBWF  x98,W
0EA0:  BNZ   0EA6
0EA2:  MOVF   x93,W
0EA4:  SUBWF  x97,W
0EA6:  BNC   0EC6
0EA8:  MOVF   x93,W
0EAA:  SUBWF  x97,F
0EAC:  MOVF   x94,W
0EAE:  BTFSS  FD8.0
0EB0:  INCFSZ x94,W
0EB2:  SUBWF  x98,F
0EB4:  MOVF   x95,W
0EB6:  BTFSS  FD8.0
0EB8:  INCFSZ x95,W
0EBA:  SUBWF  x99,F
0EBC:  MOVF   x96,W
0EBE:  BTFSS  FD8.0
0EC0:  INCFSZ x96,W
0EC2:  SUBWF  x9A,F
0EC4:  BSF    FD8.0
0EC6:  RLCF   00,F
0EC8:  RLCF   01,F
0ECA:  RLCF   02,F
0ECC:  RLCF   03,F
0ECE:  DECFSZ x9B,F
0ED0:  BRA    0E7E
0ED2:  MOVFF  97,FEF
0ED6:  MOVFF  98,FEC
0EDA:  MOVFF  99,FEC
0EDE:  MOVFF  9A,FEC
0EE2:  RETURN 0
0EE4:  MOVF   FE9,W
0EE6:  MOVWF  x87
0EE8:  MOVF   x86,W
0EEA:  MOVWF  x89
0EEC:  BZ    0F2E
0EEE:  CLRF   16
0EF0:  BTFSC  FF2.7
0EF2:  BSF    16.7
0EF4:  BCF    FF2.7
0EF6:  MOVFF  85,A9
0EFA:  MOVFF  84,A8
0EFE:  MOVFF  83,A7
0F02:  MOVFF  82,A6
0F06:  CLRF   xAD
0F08:  CLRF   xAC
0F0A:  MOVLW  20
0F0C:  MOVWF  xAB
0F0E:  MOVLW  82
0F10:  MOVWF  xAA
0F12:  CALL   0378
0F16:  BTFSC  16.7
0F18:  BSF    FF2.7
0F1A:  MOVFF  03,85
0F1E:  MOVFF  02,84
0F22:  MOVFF  01,83
0F26:  MOVFF  00,82
0F2A:  DECFSZ x89,F
0F2C:  BRA    0EEE
0F2E:  MOVLW  7E
0F30:  MOVWF  00
0F32:  CLRF   01
0F34:  BTFSC  x83.7
0F36:  BSF    01.7
0F38:  CLRF   02
0F3A:  CLRF   03
0F3C:  BCF    FD8.1
0F3E:  CLRF   16
0F40:  BTFSC  FF2.7
0F42:  BSF    16.7
0F44:  BCF    FF2.7
0F46:  MOVFF  85,A9
0F4A:  MOVFF  84,A8
0F4E:  MOVFF  83,A7
0F52:  MOVFF  82,A6
0F56:  MOVFF  03,AD
0F5A:  MOVFF  02,AC
0F5E:  MOVFF  01,AB
0F62:  MOVWF  xAA
0F64:  CALL   046A
0F68:  BTFSC  16.7
0F6A:  BSF    FF2.7
0F6C:  MOVFF  03,85
0F70:  MOVFF  02,84
0F74:  MOVFF  01,83
0F78:  MOVFF  00,82
0F7C:  MOVFF  85,92
0F80:  MOVFF  84,91
0F84:  MOVFF  83,90
0F88:  MOVFF  82,8F
0F8C:  BRA    0E16
0F8E:  MOVFF  03,85
0F92:  MOVFF  02,84
0F96:  MOVFF  01,83
0F9A:  MOVFF  00,82
0F9E:  BTFSS  x85.7
0FA0:  BRA    0FBC
0FA2:  DECF   x87,F
0FA4:  BSF    x87.5
0FA6:  COMF   x82,F
0FA8:  COMF   x83,F
0FAA:  COMF   x84,F
0FAC:  COMF   x85,F
0FAE:  INCF   x82,F
0FB0:  BTFSC  FD8.2
0FB2:  INCF   x83,F
0FB4:  BTFSC  FD8.2
0FB6:  INCF   x84,F
0FB8:  BTFSC  FD8.2
0FBA:  INCF   x85,F
0FBC:  MOVLW  3B
0FBE:  MOVWF  x8E
0FC0:  MOVLW  9A
0FC2:  MOVWF  x8D
0FC4:  MOVLW  CA
0FC6:  MOVWF  x8C
0FC8:  CLRF   x8B
0FCA:  MOVLW  0A
0FCC:  MOVWF  x89
0FCE:  MOVF   x86,W
0FD0:  BTFSC  FD8.2
0FD2:  INCF   x87,F
0FD4:  BSF    FD8.1
0FD6:  CLRF   FEA
0FD8:  MOVLW  82
0FDA:  MOVWF  FE9
0FDC:  MOVFF  85,92
0FE0:  MOVFF  84,91
0FE4:  MOVFF  83,90
0FE8:  MOVFF  82,8F
0FEC:  MOVFF  8E,96
0FF0:  MOVFF  8D,95
0FF4:  MOVFF  8C,94
0FF8:  MOVFF  8B,93
0FFC:  RCALL  0E56
0FFE:  MOVF   01,W
1000:  MOVF   00,F
1002:  BNZ   1022
1004:  INCF   x86,W
1006:  SUBWF  x89,W
1008:  BZ    1022
100A:  MOVF   x87,W
100C:  BZ    1026
100E:  ANDLW  0F
1010:  SUBWF  x89,W
1012:  BZ    1016
1014:  BC    1084
1016:  BTFSC  x87.7
1018:  BRA    1084
101A:  BTFSC  x87.6
101C:  BRA    1026
101E:  MOVLW  20
1020:  BRA    107C
1022:  MOVLW  20
1024:  ANDWF  x87,F
1026:  BTFSS  x87.5
1028:  BRA    1042
102A:  BCF    x87.5
102C:  MOVF   x86,W
102E:  BTFSS  FD8.2
1030:  DECF   x87,F
1032:  MOVF   00,W
1034:  MOVWF  x87
1036:  MOVLW  2D
1038:  MOVWF  x8F
103A:  RCALL  0C5C
103C:  MOVF   x87,W
103E:  MOVWF  00
1040:  CLRF   x87
1042:  MOVF   x86,W
1044:  SUBWF  x89,W
1046:  BNZ   105C
1048:  MOVF   00,W
104A:  MOVWF  x87
104C:  MOVLW  2E
104E:  MOVWF  x8F
1050:  RCALL  0C5C
1052:  MOVF   x87,W
1054:  MOVWF  00
1056:  MOVLW  20
1058:  ANDWF  x87,F
105A:  MOVLW  00
105C:  MOVLW  30
105E:  BTFSS  x87.5
1060:  BRA    107C
1062:  BCF    x87.5
1064:  MOVF   x86,W
1066:  BTFSS  FD8.2
1068:  DECF   x87,F
106A:  MOVF   00,W
106C:  MOVWF  x87
106E:  MOVLW  2D
1070:  MOVWF  x8F
1072:  RCALL  0C5C
1074:  MOVF   x87,W
1076:  MOVWF  00
1078:  CLRF   x87
107A:  MOVLW  30
107C:  ADDWF  00,F
107E:  MOVFF  00,8F
1082:  RCALL  0C5C
1084:  BCF    FD8.1
1086:  MOVFF  8E,92
108A:  MOVFF  8D,91
108E:  MOVFF  8C,90
1092:  MOVFF  8B,8F
1096:  CLRF   x96
1098:  CLRF   x95
109A:  CLRF   x94
109C:  MOVLW  0A
109E:  MOVWF  x93
10A0:  RCALL  0E56
10A2:  MOVFF  03,8E
10A6:  MOVFF  02,8D
10AA:  MOVFF  01,8C
10AE:  MOVFF  00,8B
10B2:  DECFSZ x89,F
10B4:  BRA    0FD4
10B6:  RETURN 0
*
13A4:  MOVF   FE9,W
13A6:  MOVWF  x86
13A8:  MOVLW  3B
13AA:  MOVWF  x8D
13AC:  MOVLW  9A
13AE:  MOVWF  x8C
13B0:  MOVLW  CA
13B2:  MOVWF  x8B
13B4:  CLRF   x8A
13B6:  MOVLW  0A
13B8:  MOVWF  x88
13BA:  BSF    FD8.1
13BC:  CLRF   FEA
13BE:  MOVLW  82
13C0:  MOVWF  FE9
13C2:  MOVFF  85,92
13C6:  MOVFF  84,91
13CA:  MOVFF  83,90
13CE:  MOVFF  82,8F
13D2:  MOVFF  8D,96
13D6:  MOVFF  8C,95
13DA:  MOVFF  8B,94
13DE:  MOVFF  8A,93
13E2:  RCALL  0E56
13E4:  MOVF   01,W
13E6:  MOVF   00,F
13E8:  BNZ   1408
13EA:  MOVF   x88,W
13EC:  XORLW  01
13EE:  BZ    1408
13F0:  MOVF   x86,W
13F2:  BZ    140A
13F4:  ANDLW  0F
13F6:  SUBWF  x88,W
13F8:  BZ    13FC
13FA:  BC    1414
13FC:  BTFSC  x86.7
13FE:  BRA    1414
1400:  BTFSC  x86.6
1402:  BRA    140A
1404:  MOVLW  20
1406:  BRA    140C
1408:  CLRF   x86
140A:  MOVLW  30
140C:  ADDWF  00,F
140E:  MOVFF  00,8F
1412:  RCALL  0C5C
1414:  BCF    FD8.1
1416:  MOVFF  8D,92
141A:  MOVFF  8C,91
141E:  MOVFF  8B,90
1422:  MOVFF  8A,8F
1426:  CLRF   x96
1428:  CLRF   x95
142A:  CLRF   x94
142C:  MOVLW  0A
142E:  MOVWF  x93
1430:  RCALL  0E56
1432:  MOVFF  03,8D
1436:  MOVFF  02,8C
143A:  MOVFF  01,8B
143E:  MOVFF  00,8A
1442:  DECFSZ x88,F
1444:  BRA    13BA
1446:  RETURN 0
....................  
.................... #list 
....................  
.................... #device adc=10 
.................... #fuses HSPLL, PLL5, USBDIV, CPUDIV1, NOWDT,NOPROTECT,NOLVP,NODEBUG,VREGEN,PUT,NOMCLR BROWNOUT//,BORV25 
.................... #use delay(clock=48m) 
*
0AA6:  CLRF   FEA
0AA8:  MOVLW  90
0AAA:  MOVWF  FE9
0AAC:  MOVF   FEF,W
0AAE:  BZ    0ACC
0AB0:  MOVLW  0F
0AB2:  MOVWF  01
0AB4:  CLRF   00
0AB6:  DECFSZ 00,F
0AB8:  BRA    0AB6
0ABA:  DECFSZ 01,F
0ABC:  BRA    0AB4
0ABE:  MOVLW  8F
0AC0:  MOVWF  00
0AC2:  DECFSZ 00,F
0AC4:  BRA    0AC2
0AC6:  NOP   
0AC8:  DECFSZ FEF,F
0ACA:  BRA    0AB0
0ACC:  RETURN 0
.................... #use standard_io(B) 
.................... //#use standard_io(c) 
.................... //#use standard_io(d) 
.................... #include<includes.c> 
.................... //18F 
....................  
.................... #byte PORTA = 0xF80 
.................... #byte PORTB = 0xF81 
.................... #byte PORTC = 0xF82 
.................... #byte PORTD = 0xF83 
.................... #byte PORTE = 0xF84 
.................... #byte TRISB = 0xf93 
.................... #byte ADRESH = 0xfc4 
.................... #byte ADRESL = 0xfc3 
.................... #byte CMCON = 0xfB4 
.................... #byte CVRCON = 0xfB5 
.................... #byte ADCON1 = 0xfC1 
.................... #byte ADCON2 = 0xfC0 
.................... #byte STATUS = 0xFD8 
.................... #byte SPPCON = 0xF65 
....................  
.................... #define BEEP pin_B7 
.................... #define RESISTENCIA_Z1 pin_D5 
.................... #define RESISTENCIA_Z2 pin_D6 
.................... #define RESISTENCIA_Z3 pin_D0 
.................... #define RESISTENCIA_Z4 pin_C1 
.................... /* 
.................... #define ELECTROVALVULA_Z1 pin_C1 
.................... #define ELECTROVALVULA_Z2 pin_D1 
.................... #define ELECTROVALVULA_Z3 pin_D0 
.................... #define ELECTROVALVULA_Z4 pin_D5 
.................... #define CONTACTOR_MOTOR pin_C0 
.................... #define CONTACTOR_TEMPERATURA pin_C6 
.................... #define CONTACTOR_PELETIZADORA pin_C2 
.................... #define MONITOR_FASES pin_D2 
.................... #define RPM_MOTOR pin_E2 
.................... #define COOLER_MOTOR pin_A4 
.................... #define TEMPERATURA_MOTOR pin_E0 
.................... #define CORRIENTE_MOTOR pin_E1 
.................... #define TEMPERATURA_AMBIENTE pin_A5 
.................... #define TERMOCUPLA_Z1 pin_A0 
.................... #define TERMOCUPLA_Z2 pin_A1 
.................... #define TERMOCUPLA_Z3 pin_A2 
.................... #define TERMOCUPLA_Z4 pin_A3 
.................... #define SW_TEMPERATURAS pin_D7 
.................... */ 
.................... #define DIR_SPZ1     6 
.................... #define DIR_SPZ2     4 
.................... #define DIR_SPZ3     2 
.................... #define DIR_SPZ4     0 
.................... #define DIR_SP_T_MOT 10 
.................... #define DIR_SP_I_MOT 8 
.................... #define DIR_MAX_Z1   12 
.................... #define DIR_MAX_Z2   14 
.................... #define DIR_MAX_Z3   16 
.................... #define DIR_MAX_Z4   18 
.................... #define DIR_OFF_Z1   20 
.................... #define DIR_OFF_Z2   22 
.................... #define DIR_OFF_Z3   24 
.................... #define DIR_OFF_Z4   26 
.................... #define DIR_MAX_MOT  28 
.................... #define DIR_MAX_AMB  30 
.................... #define DIR_OFF_MOT  32 
.................... #define DIR_OFF_AMB  34 
....................  
.................... INT32 ADC_TERMOCUPLA_Z1 =0; 
.................... INT32 ADC_TERMOCUPLA_Z2 =0; 
.................... INT32 ADC_TERMOCUPLA_Z3 =0; 
.................... INT32 ADC_TERMOCUPLA_Z4 =0; 
.................... INT32 ADC_TEMPERATURA_AMBIENTE =0; 
.................... INT32 ADC_TEMPERATURA_MOTOR =0; 
....................  
....................  
.................... FLOAT Temp_Z1; 
.................... FLOAT Temp_Z2; 
.................... FLOAT Temp_Z3; 
.................... FLOAT Temp_Z4; 
.................... INT16 Temp_Mot; 
.................... INT16 Temp_Amb; 
.................... INT16 flag; 
....................  
.................... INT16 SP_Z1=0 ; 
.................... INT16 SP_Z2=0 ; 
.................... INT16 SP_Z3=0 ; 
.................... INT16 SP_Z4=0 ; 
.................... INT16 SP_I_MOT ; 
.................... INT16 SP_T_MOT ; 
....................  
.................... INT16 OFFSET_Z1; 
.................... INT16 OFFSET_Z2; 
.................... INT16 OFFSET_Z3; 
.................... INT16 OFFSET_Z4; 
.................... INT16 OFFSET_AMB; 
.................... INT16 OFFSET_MOT; 
....................  
.................... INT16 MAX_Z1; 
.................... INT16 MAX_Z2; 
.................... INT16 MAX_Z3; 
.................... INT16 MAX_Z4; 
.................... INT16 MAX_AMB; 
.................... INT16 MAX_MOT; 
.................... //teclado2 
.................... #byte PORT = 0xF81 
.................... #byte PORTB = 0xF81 
.................... #byte TRISB = 0xf93 
.................... #byte PORTC = 0xF82 
.................... //#define BEEP pin_B7 
....................  
.................... INT8 Pantalla_actual=0; 
....................  
.................... //INT8 PANTALLAS_1=1; 
.................... //INT8 PANTALLAS_2=1; 
.................... //INT8 PANTALLAS_3=0; 
....................  
.................... //eeprom 
....................  
....................  
....................  
.................... INT8 flag_programacion=0; 
.................... INT8 CONTADOR_SP = 1; // CONTIENE EL VALOS DEL SET POINT SELECCIONADO  
.................... INT8 FLAG_BOTON = 0; // REGISTRO DE FLAGS DE LOS BOTONED 
.................... #bit FLAG_CENTRO_SP = FLAG_BOTON.4 //0 = FUERA DEL MODO DE PROGRAMACION DE LOS SET POINTS / 1 = MODO DE PROGRAMACION DE LOS SET POINTS 
.................... #bit FLAG_FIN_SP1 = FLAG_BOTON.3 // FLAG QUE INDICA CUANDO GUARDAR EN EEPROM 
.................... #bit FLAG_FIN_SP2 = FLAG_BOTON.2 
....................  
....................  
.................... #include<FLEX_LCD420.c> //Dedino los pines de conexión del LCS en el driver FLEX_LCD420.c 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... #define LCD_DB4   PIN_B3  
.................... #define LCD_DB5   PIN_B4  
.................... #define LCD_DB6   PIN_B5  
.................... #define LCD_DB7   PIN_B6  
....................  
.................... #define LCD_RS    PIN_B0  
.................... #define LCD_RW    PIN_B1  
.................... #define LCD_E     PIN_B2  
....................  
.................... /* 
.................... #define LCD_RS_PIN PIN_b0 
.................... #define LCD_RW_PIN PIN_b1 
.................... #define LCD_ENABLE_PIN PIN_b2 
.................... #define LCD_DATA4 PIN_b3 
.................... #define LCD_DATA5 PIN_b4 
.................... #define LCD_DATA6 PIN_b5 
.................... #define LCD_DATA7 PIN_b6 
.................... */ 
....................  
....................  
.................... /*  
.................... // To prove that the driver can be used with random  
.................... // pins, I also tested it with these pins:  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_B1  
.................... #define LCD_DB6   PIN_C5  
.................... #define LCD_DB7   PIN_B5  
....................  
.................... #define LCD_RS    PIN_E2  
.................... #define LCD_RW    PIN_B2  
.................... #define LCD_E     PIN_D6  
.................... */  
....................  
.................... // If you want only a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  Doing so will save one PIC  
.................... // pin, but at the cost of losing the ability to read from  
.................... // the LCD.  It also makes the write time a little longer  
.................... // because a static delay must be used, instead of polling  
.................... // the LCD's busy bit.  Normally a 6-pin interface is only  
.................... // used if you are running out of PIC pins, and you need  
.................... // to use as few as possible for the LCD.  
.................... #define USE_RW_PIN   1       
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
....................  
.................... //========================================  
....................  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
0ACE:  BTFSC  x97.0
0AD0:  BRA    0AD6
0AD2:  BCF    F8A.3
0AD4:  BRA    0AD8
0AD6:  BSF    F8A.3
0AD8:  BCF    F93.3
....................  output_bit(LCD_DB5, !!(nibble & 2));   
0ADA:  BTFSC  x97.1
0ADC:  BRA    0AE2
0ADE:  BCF    F8A.4
0AE0:  BRA    0AE4
0AE2:  BSF    F8A.4
0AE4:  BCF    F93.4
....................  output_bit(LCD_DB6, !!(nibble & 4));     
0AE6:  BTFSC  x97.2
0AE8:  BRA    0AEE
0AEA:  BCF    F8A.5
0AEC:  BRA    0AF0
0AEE:  BSF    F8A.5
0AF0:  BCF    F93.5
....................  output_bit(LCD_DB7, !!(nibble & 8));     
0AF2:  BTFSC  x97.3
0AF4:  BRA    0AFA
0AF6:  BCF    F8A.6
0AF8:  BRA    0AFC
0AFA:  BSF    F8A.6
0AFC:  BCF    F93.6
....................  
....................  delay_cycles(1);  
0AFE:  NOP   
....................  output_high(LCD_E);  
0B00:  BCF    F93.2
0B02:  BSF    F8A.2
....................  delay_us(2);  
0B04:  MOVLW  07
0B06:  MOVWF  00
0B08:  DECFSZ 00,F
0B0A:  BRA    0B08
0B0C:  BRA    0B0E
....................  output_low(LCD_E);  
0B0E:  BCF    F93.2
0B10:  BCF    F8A.2
0B12:  RETURN 0
.................... }  
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
0B14:  CLRF   x98
....................      
.................... output_high(LCD_E);  
0B16:  BCF    F93.2
0B18:  BSF    F8A.2
.................... delay_us(1);  
0B1A:  MOVLW  03
0B1C:  MOVWF  00
0B1E:  DECFSZ 00,F
0B20:  BRA    0B1E
0B22:  BRA    0B24
....................  
.................... retval_0 = input(LCD_DB4);  
0B24:  BSF    F93.3
0B26:  BCF    x98.0
0B28:  BTFSC  F81.3
0B2A:  BSF    x98.0
.................... retval_1 = input(LCD_DB5);  
0B2C:  BSF    F93.4
0B2E:  BCF    x98.1
0B30:  BTFSC  F81.4
0B32:  BSF    x98.1
.................... retval_2 = input(LCD_DB6);  
0B34:  BSF    F93.5
0B36:  BCF    x98.2
0B38:  BTFSC  F81.5
0B3A:  BSF    x98.2
.................... retval_3 = input(LCD_DB7);  
0B3C:  BSF    F93.6
0B3E:  BCF    x98.3
0B40:  BTFSC  F81.6
0B42:  BSF    x98.3
....................    
.................... output_low(LCD_E);  
0B44:  BCF    F93.2
0B46:  BCF    F8A.2
.................... delay_us(1);  
0B48:  MOVLW  03
0B4A:  MOVWF  00
0B4C:  DECFSZ 00,F
0B4E:  BRA    0B4C
0B50:  BRA    0B52
....................      
.................... return(retval);     
0B52:  MOVFF  98,01
0B56:  RETURN 0
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
0B58:  BCF    F93.1
0B5A:  BSF    F8A.1
.................... delay_cycles(1);  
0B5C:  NOP   
....................  
.................... high = lcd_read_nibble();  
0B5E:  RCALL  0B14
0B60:  MOVFF  01,97
....................  
.................... low = lcd_read_nibble();  
0B64:  RCALL  0B14
0B66:  MOVFF  01,96
....................  
.................... return( (high<<4) | low);  
0B6A:  SWAPF  x97,W
0B6C:  MOVWF  00
0B6E:  MOVLW  F0
0B70:  ANDWF  00,F
0B72:  MOVF   00,W
0B74:  IORWF  x96,W
0B76:  MOVWF  01
0B78:  GOTO   0B82 (RETURN)
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
0B7C:  BCF    F93.0
0B7E:  BCF    F8A.0
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
0B80:  BRA    0B58
0B82:  MOVFF  01,96
0B86:  BTFSC  01.7
0B88:  BRA    0B80
.................... #else  
.................... delay_us(60);   
.................... #endif  
....................  
.................... if(address)  
0B8A:  MOVF   x94,F
0B8C:  BZ    0B94
....................    output_high(LCD_RS);  
0B8E:  BCF    F93.0
0B90:  BSF    F8A.0
0B92:  BRA    0B98
.................... else  
....................    output_low(LCD_RS);  
0B94:  BCF    F93.0
0B96:  BCF    F8A.0
....................        
....................  delay_cycles(1);  
0B98:  NOP   
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
0B9A:  BCF    F93.1
0B9C:  BCF    F8A.1
.................... delay_cycles(1);  
0B9E:  NOP   
.................... #endif  
....................  
.................... output_low(LCD_E);  
0BA0:  BCF    F93.2
0BA2:  BCF    F8A.2
....................  
.................... lcd_send_nibble(n >> 4);  
0BA4:  SWAPF  x95,W
0BA6:  MOVWF  x96
0BA8:  MOVLW  0F
0BAA:  ANDWF  x96,F
0BAC:  MOVFF  96,97
0BB0:  RCALL  0ACE
.................... lcd_send_nibble(n & 0xf);  
0BB2:  MOVF   x95,W
0BB4:  ANDLW  0F
0BB6:  MOVWF  x96
0BB8:  MOVWF  x97
0BBA:  RCALL  0ACE
0BBC:  RETURN 0
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
.................... int8 i;  
....................  
.................... lcd_line = 1;  
0BBE:  MOVLW  01
0BC0:  MOVWF  x6D
....................  
.................... output_low(LCD_RS);  
0BC2:  BCF    F93.0
0BC4:  BCF    F8A.0
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
0BC6:  BCF    F93.1
0BC8:  BCF    F8A.1
.................... #endif  
....................  
.................... output_low(LCD_E);  
0BCA:  BCF    F93.2
0BCC:  BCF    F8A.2
....................  
.................... // Some LCDs require 15 ms minimum delay after  
.................... // power-up.  Others require 30 ms.  I'm going  
.................... // to set it to 35 ms, so it should work with  
.................... // all of them.  
.................... delay_ms(35);           
0BCE:  MOVLW  23
0BD0:  MOVWF  x90
0BD2:  RCALL  0AA6
....................  
.................... for(i=0 ;i < 3; i++)  
0BD4:  CLRF   x81
0BD6:  MOVF   x81,W
0BD8:  SUBLW  02
0BDA:  BNC   0BEC
....................    {  
....................     lcd_send_nibble(0x03);  
0BDC:  MOVLW  03
0BDE:  MOVWF  x97
0BE0:  RCALL  0ACE
....................     delay_ms(5);  
0BE2:  MOVLW  05
0BE4:  MOVWF  x90
0BE6:  RCALL  0AA6
0BE8:  INCF   x81,F
0BEA:  BRA    0BD6
....................    }  
....................  
.................... lcd_send_nibble(0x02);  
0BEC:  MOVLW  02
0BEE:  MOVWF  x97
0BF0:  RCALL  0ACE
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
0BF2:  CLRF   x81
0BF4:  MOVF   x81,W
0BF6:  SUBLW  03
0BF8:  BNC   0C18
....................    {  
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);  
0BFA:  CLRF   03
0BFC:  MOVF   x81,W
0BFE:  MOVFF  FF2,82
0C02:  BCF    FF2.7
0C04:  CALL   0096
0C08:  BTFSC  x82.7
0C0A:  BSF    FF2.7
0C0C:  MOVWF  x82
0C0E:  CLRF   x94
0C10:  MOVWF  x95
0C12:  RCALL  0B7C
....................      
....................     // If the R/W signal is not used, then  
....................     // the busy bit can't be polled.  One of  
....................     // the init commands takes longer than  
....................     // the hard-coded delay of 50 us, so in  
....................     // that case, lets just do a 5 ms delay  
....................     // after all four of them.  
....................     #ifndef USE_RW_PIN  
0C14:  INCF   x81,F
0C16:  BRA    0BF4
....................     delay_ms(5);  
....................     #endif  
....................    }  
0C18:  GOTO   2952 (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
0C1C:  MOVF   x91,W
0C1E:  XORLW  01
0C20:  BZ    0C30
0C22:  XORLW  03
0C24:  BZ    0C34
0C26:  XORLW  01
0C28:  BZ    0C3A
0C2A:  XORLW  07
0C2C:  BZ    0C40
0C2E:  BRA    0C46
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
0C30:  CLRF   x92
....................      break;  
0C32:  BRA    0C48
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
0C34:  MOVLW  40
0C36:  MOVWF  x92
....................      break;  
0C38:  BRA    0C48
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
0C3A:  MOVLW  14
0C3C:  MOVWF  x92
....................      break;  
0C3E:  BRA    0C48
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
0C40:  MOVLW  54
0C42:  MOVWF  x92
....................      break;  
0C44:  BRA    0C48
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
0C46:  CLRF   x92
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
0C48:  MOVLW  01
0C4A:  SUBWF  x90,W
0C4C:  ADDWF  x92,F
.................... lcd_send_byte(0, 0x80 | address);  
0C4E:  MOVF   x92,W
0C50:  IORLW  80
0C52:  MOVWF  x93
0C54:  CLRF   x94
0C56:  MOVWF  x95
0C58:  RCALL  0B7C
0C5A:  RETURN 0
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
0C5C:  MOVF   x8F,W
0C5E:  XORLW  0C
0C60:  BZ    0C6C
0C62:  XORLW  06
0C64:  BZ    0C80
0C66:  XORLW  02
0C68:  BZ    0C8E
0C6A:  BRA    0C98
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
0C6C:  CLRF   x94
0C6E:  MOVLW  01
0C70:  MOVWF  x95
0C72:  RCALL  0B7C
....................       lcd_line = 1;  
0C74:  MOVLW  01
0C76:  MOVWF  x6D
....................       delay_ms(2);  
0C78:  MOVLW  02
0C7A:  MOVWF  x90
0C7C:  RCALL  0AA6
....................       break;  
0C7E:  BRA    0CA2
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
0C80:  INCF   x6D,F
0C82:  MOVLW  01
0C84:  MOVWF  x90
0C86:  MOVFF  6D,91
0C8A:  RCALL  0C1C
....................        break;  
0C8C:  BRA    0CA2
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
0C8E:  CLRF   x94
0C90:  MOVLW  10
0C92:  MOVWF  x95
0C94:  RCALL  0B7C
....................        break;  
0C96:  BRA    0CA2
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
0C98:  MOVLW  01
0C9A:  MOVWF  x94
0C9C:  MOVFF  8F,95
0CA0:  RCALL  0B7C
....................        break;  
....................    }  
0CA2:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include<Base.c> 
.................... void Beep_corto(void); 
.................... void Beep_largo(void); 
.................... void Guardar_EEPROM(INT16 dato,INT16 dir); 
.................... INT16 Leer_EEPROM(INT16 dir); 
....................  
....................  
....................  
.................... INT16 Leer_EEPROM(INT16 dir){ 
*
0D04:  CLRF   x83
0D06:  CLRF   x84
0D08:  CLRF   x86
0D0A:  CLRF   x85
....................    INT8 low=0; 
....................    INT8 high=0; 
....................    INT16 res=0; 
....................    low = READ_EEPROM(dir); 
0D0C:  MOVFF  FF2,87
0D10:  BCF    FF2.7
0D12:  MOVFF  81,FA9
0D16:  BCF    FA6.6
0D18:  BCF    FA6.7
0D1A:  BSF    FA6.0
0D1C:  MOVF   FA8,W
0D1E:  BTFSC  x87.7
0D20:  BSF    FF2.7
0D22:  MOVWF  x83
....................    high = READ_EEPROM(dir+1); 
0D24:  MOVLW  01
0D26:  ADDWF  x81,W
0D28:  MOVWF  x87
0D2A:  MOVLW  00
0D2C:  ADDWFC x82,W
0D2E:  MOVWF  x88
0D30:  MOVFF  FF2,89
0D34:  BCF    FF2.7
0D36:  MOVFF  87,FA9
0D3A:  BCF    FA6.6
0D3C:  BCF    FA6.7
0D3E:  BSF    FA6.0
0D40:  MOVF   FA8,W
0D42:  BTFSC  x89.7
0D44:  BSF    FF2.7
0D46:  MOVWF  x84
....................    res = (high << 8); 
0D48:  MOVFF  84,86
0D4C:  CLRF   x85
....................    res = (res | low); 
0D4E:  MOVF   x83,W
0D50:  IORWF  x85,F
....................    return res; 
0D52:  MOVFF  85,01
0D56:  MOVFF  86,02
0D5A:  RETURN 0
.................... } 
....................  
.................... void Guardar_EEPROM(INT16 dato,INT16 dir){                      //SP_Z4     0 
....................   INT8 aux_l ;                                                  //SP_Z3     2 
....................   INT8 aux_h ;                                                  //SP_Z2     4 
....................   INT16 aux;                                                    //SP_Z1     6 
....................  
....................   aux_l = READ_EEPROM(dir); 
*
219C:  MOVFF  FF2,8B
21A0:  BCF    FF2.7
21A2:  MOVFF  85,FA9
21A6:  BCF    FA6.6
21A8:  BCF    FA6.7
21AA:  BSF    FA6.0
21AC:  MOVF   FA8,W
21AE:  BTFSC  x8B.7
21B0:  BSF    FF2.7
21B2:  MOVWF  x87
....................   aux_h = READ_EEPROM(dir+1);  
21B4:  MOVLW  01
21B6:  ADDWF  x85,W
21B8:  MOVWF  x8B
21BA:  MOVLW  00
21BC:  ADDWFC x86,W
21BE:  MOVWF  x8C
21C0:  MOVFF  FF2,8D
21C4:  BCF    FF2.7
21C6:  MOVFF  8B,FA9
21CA:  BCF    FA6.6
21CC:  BCF    FA6.7
21CE:  BSF    FA6.0
21D0:  MOVF   FA8,W
21D2:  BTFSC  x8D.7
21D4:  BSF    FF2.7
21D6:  MOVWF  x88
....................   aux = (aux_h << 8); 
21D8:  MOVFF  88,8A
21DC:  CLRF   x89
....................   aux = (aux | aux_l); 
21DE:  MOVF   x87,W
21E0:  IORWF  x89,F
....................   if(aux==dato){   
21E2:  MOVF   x83,W
21E4:  SUBWF  x89,W
21E6:  BNZ   21F2
21E8:  MOVF   x84,W
21EA:  SUBWF  x8A,W
21EC:  BNZ   21F2
....................    return; 
21EE:  BRA    2268
....................   } 
21F0:  BRA    2268
....................  
....................   else{ 
....................        aux_l = 0; 
21F2:  CLRF   x87
....................       aux_h = 0; 
21F4:  CLRF   x88
....................       aux_l=dato; 
21F6:  MOVFF  83,87
....................       dato=(dato>>8); 
21FA:  MOVFF  84,83
21FE:  CLRF   x84
....................       aux_h=dato; 
2200:  MOVFF  83,88
....................       WRITE_EEPROM(dir, aux_l); 
2204:  MOVF   FF2,W
2206:  MOVWF  00
2208:  BCF    FF2.7
220A:  MOVFF  85,FA9
220E:  MOVFF  87,FA8
2212:  BCF    FA6.6
2214:  BCF    FA6.7
2216:  BSF    FA6.2
2218:  MOVLB  F
221A:  MOVLW  55
221C:  MOVWF  FA7
221E:  MOVLW  AA
2220:  MOVWF  FA7
2222:  BSF    FA6.1
2224:  BTFSC  FA6.1
2226:  BRA    2224
2228:  BCF    FA6.2
222A:  MOVF   00,W
222C:  IORWF  FF2,F
....................       WRITE_EEPROM(dir+1, aux_h); 
222E:  MOVLW  01
2230:  MOVLB  0
2232:  ADDWF  x85,W
2234:  MOVWF  x8B
2236:  MOVLW  00
2238:  ADDWFC x86,W
223A:  MOVWF  x8C
223C:  MOVF   FF2,W
223E:  MOVWF  00
2240:  BCF    FF2.7
2242:  MOVFF  8B,FA9
2246:  MOVFF  88,FA8
224A:  BCF    FA6.6
224C:  BCF    FA6.7
224E:  BSF    FA6.2
2250:  MOVLB  F
2252:  MOVLW  55
2254:  MOVWF  FA7
2256:  MOVLW  AA
2258:  MOVWF  FA7
225A:  BSF    FA6.1
225C:  BTFSC  FA6.1
225E:  BRA    225C
2260:  BCF    FA6.2
2262:  MOVF   00,W
2264:  IORWF  FF2,F
2266:  MOVLB  0
....................   /* 
....................       aux_l = 0; 
....................       aux_h = 0; 
....................       if (bit_test(dato,0) == 1 ) bit_SET(aux_l,0); 
....................       if (bit_test(dato,1) == 1 ) bit_SET(aux_l,1); 
....................       if (bit_test(dato,2) == 1 ) bit_SET(aux_l,2); 
....................       if (bit_test(dato,3) == 1 ) bit_SET(aux_l,3); 
....................       if (bit_test(dato,4) == 1 ) bit_SET(aux_l,4); 
....................       if (bit_test(dato,5) == 1 ) bit_SET(aux_l,5); 
....................       if (bit_test(dato,6) == 1 ) bit_SET(aux_l,6); 
....................       if (bit_test(dato,7) == 1 ) bit_SET(aux_l,7); 
....................       if (bit_test(dato,8) == 1 ) bit_SET(aux_h,0); 
....................       bit_CLEAR(aux_h,9); 
....................       bit_CLEAR(aux_h,10); 
....................       bit_CLEAR(aux_h,11); 
....................       bit_CLEAR(aux_h,12); 
....................       bit_CLEAR(aux_h,13); 
....................       bit_CLEAR(aux_h,14); 
....................       bit_CLEAR(aux_h,15);          
....................       WRITE_EEPROM(dir, aux_l); 
....................       WRITE_EEPROM(dir+1, aux_h); 
....................       return;  */ 
....................   } 
2268:  RETURN 0
.................... } 
....................  
....................  
.................... void Beep_largo(void){ 
....................    OUTPUT_HIGH(BEEP); 
*
0CC4:  BCF    F93.7
0CC6:  BSF    F8A.7
....................    delay_ms(200); 
0CC8:  MOVLW  C8
0CCA:  MOVWF  x90
0CCC:  RCALL  0AA6
....................    OUTPUT_LOW(BEEP); 
0CCE:  BCF    F93.7
0CD0:  BCF    F8A.7
....................     
....................    delay_ms(100); 
0CD2:  MOVLW  64
0CD4:  MOVWF  x90
0CD6:  RCALL  0AA6
....................     
....................    OUTPUT_HIGH(BEEP); 
0CD8:  BCF    F93.7
0CDA:  BSF    F8A.7
....................    delay_ms(50); 
0CDC:  MOVLW  32
0CDE:  MOVWF  x90
0CE0:  RCALL  0AA6
....................    OUTPUT_LOW(BEEP); 
0CE2:  BCF    F93.7
0CE4:  BCF    F8A.7
....................    delay_ms(50); 
0CE6:  MOVLW  32
0CE8:  MOVWF  x90
0CEA:  RCALL  0AA6
....................    OUTPUT_HIGH(BEEP); 
0CEC:  BCF    F93.7
0CEE:  BSF    F8A.7
....................    delay_ms(50); 
0CF0:  MOVLW  32
0CF2:  MOVWF  x90
0CF4:  RCALL  0AA6
....................    OUTPUT_LOW(BEEP); 
0CF6:  BCF    F93.7
0CF8:  BCF    F8A.7
....................    delay_ms(50); 
0CFA:  MOVLW  32
0CFC:  MOVWF  x90
0CFE:  RCALL  0AA6
0D00:  GOTO   299C (RETURN)
.................... } 
....................  
.................... void Beep_corto(void){    
....................    OUTPUT_HIGH(BEEP); 
*
226A:  BCF    F93.7
226C:  BSF    F8A.7
....................    delay_ms(50); 
226E:  MOVLW  32
2270:  MOVWF  x90
2272:  CALL   0AA6
....................    OUTPUT_LOW(BEEP); 
2276:  BCF    F93.7
2278:  BCF    F8A.7
....................    delay_ms(50); 
227A:  MOVLW  32
227C:  MOVWF  x90
227E:  CALL   0AA6
....................    OUTPUT_HIGH(BEEP); 
2282:  BCF    F93.7
2284:  BSF    F8A.7
....................    delay_ms(50); 
2286:  MOVLW  32
2288:  MOVWF  x90
228A:  CALL   0AA6
....................    OUTPUT_LOW(BEEP); 
228E:  BCF    F93.7
2290:  BCF    F8A.7
....................    delay_ms(50); 
2292:  MOVLW  32
2294:  MOVWF  x90
2296:  CALL   0AA6
229A:  GOTO   2414 (RETURN)
.................... } 
....................  
.................... #include<TECLADO2.c> 
....................  
.................... #define SW_CENTRO    1 
.................... #define SW_ARRIBA    3 
.................... #define SW_ABAJO     2 
.................... #define SW_IZQUIERDA 4 
.................... #define SW_DERECHA   5 
.................... #define SW_NOKEY     0 
.................... //ABAJO PB1 
.................... //ARRIBA PB6 
.................... //DERECHA PB5 
.................... //IZQUIERDA PB3 
.................... //CENTRO PB4 
.................... VOID TRIS_IN(){ 
.................... //TRISB ENTRADAS 
....................          bit_SET(TRISB,1); 
*
1A9A:  BSF    F93.1
....................          bit_SET(TRISB,3); 
1A9C:  BSF    F93.3
....................          bit_SET(TRISB,4); 
1A9E:  BSF    F93.4
....................          bit_SET(TRISB,5); 
1AA0:  BSF    F93.5
....................          bit_SET(TRISB,6); 
1AA2:  BSF    F93.6
....................          delay_ms(20);  
1AA4:  MOVLW  14
1AA6:  MOVWF  x90
1AA8:  CALL   0AA6
1AAC:  GOTO   1AB2 (RETURN)
....................          } 
....................           
.................... INT8 leer_botones(void){ 
....................   TRIS_IN(); 
1AB0:  BRA    1A9A
....................   if(bit_test (PORT,4)) // boton centro 
1AB2:  BTFSS  F81.4
1AB4:  BRA    1AEC
....................   { 
....................       flag++; 
1AB6:  INCF   43,F
1AB8:  BTFSC  FD8.2
1ABA:  INCF   44,F
....................       if(!(flag%4)&&flag>30){ 
1ABC:  MOVF   43,W
1ABE:  ANDLW  03
1AC0:  MOVWF  00
1AC2:  CLRF   03
1AC4:  MOVF   00,W
1AC6:  IORWF  03,W
1AC8:  BNZ   1ADA
1ACA:  MOVF   44,F
1ACC:  BNZ   1AD4
1ACE:  MOVF   43,W
1AD0:  SUBLW  1E
1AD2:  BC    1ADA
....................         return 1; 
1AD4:  MOVLW  01
1AD6:  MOVWF  01
1AD8:  BRA    1BC8
....................       } 
....................       if(flag==4){ 
1ADA:  MOVF   43,W
1ADC:  SUBLW  04
1ADE:  BNZ   1AEA
1AE0:  MOVF   44,F
1AE2:  BNZ   1AEA
....................         return 1; 
1AE4:  MOVLW  01
1AE6:  MOVWF  01
1AE8:  BRA    1BC8
....................       } 
....................   } 
1AEA:  BRA    1BBC
....................   else if(bit_test(PORT,6)) //boton arriba 
1AEC:  BTFSS  F81.6
1AEE:  BRA    1B26
....................   { 
....................       flag++; 
1AF0:  INCF   43,F
1AF2:  BTFSC  FD8.2
1AF4:  INCF   44,F
....................       if(!(flag%4)&&flag>30){ 
1AF6:  MOVF   43,W
1AF8:  ANDLW  03
1AFA:  MOVWF  00
1AFC:  CLRF   03
1AFE:  MOVF   00,W
1B00:  IORWF  03,W
1B02:  BNZ   1B14
1B04:  MOVF   44,F
1B06:  BNZ   1B0E
1B08:  MOVF   43,W
1B0A:  SUBLW  1E
1B0C:  BC    1B14
....................         return 2; 
1B0E:  MOVLW  02
1B10:  MOVWF  01
1B12:  BRA    1BC8
....................       } 
....................       if(flag==2){ 
1B14:  MOVF   43,W
1B16:  SUBLW  02
1B18:  BNZ   1B24
1B1A:  MOVF   44,F
1B1C:  BNZ   1B24
....................         return 2; 
1B1E:  MOVLW  02
1B20:  MOVWF  01
1B22:  BRA    1BC8
....................       } 
....................   } 
1B24:  BRA    1BBC
....................   else if(bit_test(PORT,1)) //boton abajo 
1B26:  BTFSS  F81.1
1B28:  BRA    1B60
....................   { 
....................       flag++; 
1B2A:  INCF   43,F
1B2C:  BTFSC  FD8.2
1B2E:  INCF   44,F
....................       if(!(flag%4)&&flag>30){ 
1B30:  MOVF   43,W
1B32:  ANDLW  03
1B34:  MOVWF  00
1B36:  CLRF   03
1B38:  MOVF   00,W
1B3A:  IORWF  03,W
1B3C:  BNZ   1B4E
1B3E:  MOVF   44,F
1B40:  BNZ   1B48
1B42:  MOVF   43,W
1B44:  SUBLW  1E
1B46:  BC    1B4E
....................         return 3; 
1B48:  MOVLW  03
1B4A:  MOVWF  01
1B4C:  BRA    1BC8
....................       } 
....................       if(flag==2){ 
1B4E:  MOVF   43,W
1B50:  SUBLW  02
1B52:  BNZ   1B5E
1B54:  MOVF   44,F
1B56:  BNZ   1B5E
....................         return 3; 
1B58:  MOVLW  03
1B5A:  MOVWF  01
1B5C:  BRA    1BC8
....................       } 
....................   } 
1B5E:  BRA    1BBC
....................   else if(bit_test(PORT,3)) //boton izquierda 
1B60:  BTFSS  F81.3
1B62:  BRA    1B8C
....................   { 
....................       flag++; 
1B64:  INCF   43,F
1B66:  BTFSC  FD8.2
1B68:  INCF   44,F
....................       if(flag>10){ 
1B6A:  MOVF   44,F
1B6C:  BNZ   1B74
1B6E:  MOVF   43,W
1B70:  SUBLW  0A
1B72:  BC    1B7A
....................         return 4; 
1B74:  MOVLW  04
1B76:  MOVWF  01
1B78:  BRA    1BC8
....................       } 
....................       if(flag==2){ 
1B7A:  MOVF   43,W
1B7C:  SUBLW  02
1B7E:  BNZ   1B8A
1B80:  MOVF   44,F
1B82:  BNZ   1B8A
....................         return 4; 
1B84:  MOVLW  04
1B86:  MOVWF  01
1B88:  BRA    1BC8
....................       } 
....................   } 
1B8A:  BRA    1BBC
....................   else if(bit_test(PORT,5)) //boton derecha 
1B8C:  BTFSS  F81.5
1B8E:  BRA    1BB8
....................   { 
....................       flag++; 
1B90:  INCF   43,F
1B92:  BTFSC  FD8.2
1B94:  INCF   44,F
....................       if(flag>10){ 
1B96:  MOVF   44,F
1B98:  BNZ   1BA0
1B9A:  MOVF   43,W
1B9C:  SUBLW  0A
1B9E:  BC    1BA6
....................         return 5; 
1BA0:  MOVLW  05
1BA2:  MOVWF  01
1BA4:  BRA    1BC8
....................       } 
....................       if(flag==2){ 
1BA6:  MOVF   43,W
1BA8:  SUBLW  02
1BAA:  BNZ   1BB6
1BAC:  MOVF   44,F
1BAE:  BNZ   1BB6
....................         return 5; 
1BB0:  MOVLW  05
1BB2:  MOVWF  01
1BB4:  BRA    1BC8
....................       } 
....................   } 
1BB6:  BRA    1BBC
....................   else 
....................       flag=0; 
1BB8:  CLRF   44
1BBA:  CLRF   43
....................   delay_ms(20); 
1BBC:  MOVLW  14
1BBE:  MOVWF  x90
1BC0:  CALL   0AA6
....................   return 0; 
1BC4:  MOVLW  00
1BC6:  MOVWF  01
1BC8:  GOTO   2B26 (RETURN)
.................... }   //    -------------------------------------------------------------------------------- 
.................... VOID PANTALLAS_SP1(){ 
....................    IF (CONTADOR_SP == 1) 
*
2042:  DECFSZ x6B,W
2044:  BRA    2096
....................    { 
....................       lcd_gotoxy(15,1); 
2046:  MOVLW  0F
2048:  MOVWF  x90
204A:  MOVLW  01
204C:  MOVWF  x91
204E:  CALL   0C1C
....................       printf(lcd_putc,">"); 
2052:  MOVLW  3E
2054:  MOVWF  x8F
2056:  CALL   0C5C
....................       lcd_gotoxy(15,2); 
205A:  MOVLW  0F
205C:  MOVWF  x90
205E:  MOVLW  02
2060:  MOVWF  x91
2062:  CALL   0C1C
....................       printf(lcd_putc," "); 
2066:  MOVLW  20
2068:  MOVWF  x8F
206A:  CALL   0C5C
....................       lcd_gotoxy(15,3); 
206E:  MOVLW  0F
2070:  MOVWF  x90
2072:  MOVLW  03
2074:  MOVWF  x91
2076:  CALL   0C1C
....................       printf(lcd_putc," "); 
207A:  MOVLW  20
207C:  MOVWF  x8F
207E:  CALL   0C5C
....................       lcd_gotoxy(15,4); 
2082:  MOVLW  0F
2084:  MOVWF  x90
2086:  MOVLW  04
2088:  MOVWF  x91
208A:  CALL   0C1C
....................       printf(lcd_putc," "); 
208E:  MOVLW  20
2090:  MOVWF  x8F
2092:  CALL   0C5C
....................    }       
....................    IF (CONTADOR_SP == 2) 
2096:  MOVF   x6B,W
2098:  SUBLW  02
209A:  BNZ   20EC
....................    { 
....................       lcd_gotoxy(15,1); 
209C:  MOVLW  0F
209E:  MOVWF  x90
20A0:  MOVLW  01
20A2:  MOVWF  x91
20A4:  CALL   0C1C
....................       printf(lcd_putc," "); 
20A8:  MOVLW  20
20AA:  MOVWF  x8F
20AC:  CALL   0C5C
....................       lcd_gotoxy(15,2); 
20B0:  MOVLW  0F
20B2:  MOVWF  x90
20B4:  MOVLW  02
20B6:  MOVWF  x91
20B8:  CALL   0C1C
....................       printf(lcd_putc,">"); 
20BC:  MOVLW  3E
20BE:  MOVWF  x8F
20C0:  CALL   0C5C
....................       lcd_gotoxy(15,3); 
20C4:  MOVLW  0F
20C6:  MOVWF  x90
20C8:  MOVLW  03
20CA:  MOVWF  x91
20CC:  CALL   0C1C
....................       printf(lcd_putc," "); 
20D0:  MOVLW  20
20D2:  MOVWF  x8F
20D4:  CALL   0C5C
....................       lcd_gotoxy(15,4); 
20D8:  MOVLW  0F
20DA:  MOVWF  x90
20DC:  MOVLW  04
20DE:  MOVWF  x91
20E0:  CALL   0C1C
....................       printf(lcd_putc," "); 
20E4:  MOVLW  20
20E6:  MOVWF  x8F
20E8:  CALL   0C5C
....................    } 
....................     
....................    IF (CONTADOR_SP == 3) 
20EC:  MOVF   x6B,W
20EE:  SUBLW  03
20F0:  BNZ   2142
....................    { 
....................       lcd_gotoxy(15,1); 
20F2:  MOVLW  0F
20F4:  MOVWF  x90
20F6:  MOVLW  01
20F8:  MOVWF  x91
20FA:  CALL   0C1C
....................       printf(lcd_putc," "); 
20FE:  MOVLW  20
2100:  MOVWF  x8F
2102:  CALL   0C5C
....................       lcd_gotoxy(15,2); 
2106:  MOVLW  0F
2108:  MOVWF  x90
210A:  MOVLW  02
210C:  MOVWF  x91
210E:  CALL   0C1C
....................       printf(lcd_putc," "); 
2112:  MOVLW  20
2114:  MOVWF  x8F
2116:  CALL   0C5C
....................       lcd_gotoxy(15,3); 
211A:  MOVLW  0F
211C:  MOVWF  x90
211E:  MOVLW  03
2120:  MOVWF  x91
2122:  CALL   0C1C
....................       printf(lcd_putc,">"); 
2126:  MOVLW  3E
2128:  MOVWF  x8F
212A:  CALL   0C5C
....................       lcd_gotoxy(15,4); 
212E:  MOVLW  0F
2130:  MOVWF  x90
2132:  MOVLW  04
2134:  MOVWF  x91
2136:  CALL   0C1C
....................       printf(lcd_putc," "); 
213A:  MOVLW  20
213C:  MOVWF  x8F
213E:  CALL   0C5C
....................    } 
....................    IF (CONTADOR_SP == 4) 
2142:  MOVF   x6B,W
2144:  SUBLW  04
2146:  BNZ   2198
....................    { 
....................       lcd_gotoxy(15,1); 
2148:  MOVLW  0F
214A:  MOVWF  x90
214C:  MOVLW  01
214E:  MOVWF  x91
2150:  CALL   0C1C
....................       printf(lcd_putc," "); 
2154:  MOVLW  20
2156:  MOVWF  x8F
2158:  CALL   0C5C
....................       lcd_gotoxy(15,2); 
215C:  MOVLW  0F
215E:  MOVWF  x90
2160:  MOVLW  02
2162:  MOVWF  x91
2164:  CALL   0C1C
....................       printf(lcd_putc," "); 
2168:  MOVLW  20
216A:  MOVWF  x8F
216C:  CALL   0C5C
....................       lcd_gotoxy(15,3); 
2170:  MOVLW  0F
2172:  MOVWF  x90
2174:  MOVLW  03
2176:  MOVWF  x91
2178:  CALL   0C1C
....................       printf(lcd_putc," "); 
217C:  MOVLW  20
217E:  MOVWF  x8F
2180:  CALL   0C5C
....................       lcd_gotoxy(15,4); 
2184:  MOVLW  0F
2186:  MOVWF  x90
2188:  MOVLW  04
218A:  MOVWF  x91
218C:  CALL   0C1C
....................       printf(lcd_putc,">"); 
2190:  MOVLW  3E
2192:  MOVWF  x8F
2194:  CALL   0C5C
....................    } 
2198:  GOTO   22B4 (RETURN)
.................... } 
.................... VOID PANTALLAS_SP(){ 
....................  
.................... if(Pantalla_actual==2||Pantalla_actual==3){ 
*
1C2C:  MOVF   x69,W
1C2E:  SUBLW  02
1C30:  BZ    1C3A
1C32:  MOVF   x69,W
1C34:  SUBLW  03
1C36:  BTFSS  FD8.2
1C38:  BRA    1EEA
....................    IF (CONTADOR_SP == 1) 
1C3A:  DECFSZ x6B,W
1C3C:  BRA    1C8E
....................    { 
....................       lcd_gotoxy(10,1); 
1C3E:  MOVLW  0A
1C40:  MOVWF  x90
1C42:  MOVLW  01
1C44:  MOVWF  x91
1C46:  CALL   0C1C
....................       printf(lcd_putc,"<"); 
1C4A:  MOVLW  3C
1C4C:  MOVWF  x8F
1C4E:  CALL   0C5C
....................       lcd_gotoxy(10,2); 
1C52:  MOVLW  0A
1C54:  MOVWF  x90
1C56:  MOVLW  02
1C58:  MOVWF  x91
1C5A:  CALL   0C1C
....................       printf(lcd_putc," "); 
1C5E:  MOVLW  20
1C60:  MOVWF  x8F
1C62:  CALL   0C5C
....................       lcd_gotoxy(10,3); 
1C66:  MOVLW  0A
1C68:  MOVWF  x90
1C6A:  MOVLW  03
1C6C:  MOVWF  x91
1C6E:  CALL   0C1C
....................       printf(lcd_putc," "); 
1C72:  MOVLW  20
1C74:  MOVWF  x8F
1C76:  CALL   0C5C
....................       lcd_gotoxy(10,4); 
1C7A:  MOVLW  0A
1C7C:  MOVWF  x90
1C7E:  MOVLW  04
1C80:  MOVWF  x91
1C82:  CALL   0C1C
....................       printf(lcd_putc," "); 
1C86:  MOVLW  20
1C88:  MOVWF  x8F
1C8A:  CALL   0C5C
....................    }       
....................    IF (CONTADOR_SP == 2) 
1C8E:  MOVF   x6B,W
1C90:  SUBLW  02
1C92:  BNZ   1CE4
....................    { 
....................       lcd_gotoxy(10,1); 
1C94:  MOVLW  0A
1C96:  MOVWF  x90
1C98:  MOVLW  01
1C9A:  MOVWF  x91
1C9C:  CALL   0C1C
....................       printf(lcd_putc," "); 
1CA0:  MOVLW  20
1CA2:  MOVWF  x8F
1CA4:  CALL   0C5C
....................       lcd_gotoxy(10,2); 
1CA8:  MOVLW  0A
1CAA:  MOVWF  x90
1CAC:  MOVLW  02
1CAE:  MOVWF  x91
1CB0:  CALL   0C1C
....................       printf(lcd_putc,"<"); 
1CB4:  MOVLW  3C
1CB6:  MOVWF  x8F
1CB8:  CALL   0C5C
....................       lcd_gotoxy(10,3); 
1CBC:  MOVLW  0A
1CBE:  MOVWF  x90
1CC0:  MOVLW  03
1CC2:  MOVWF  x91
1CC4:  CALL   0C1C
....................       printf(lcd_putc," "); 
1CC8:  MOVLW  20
1CCA:  MOVWF  x8F
1CCC:  CALL   0C5C
....................       lcd_gotoxy(10,4); 
1CD0:  MOVLW  0A
1CD2:  MOVWF  x90
1CD4:  MOVLW  04
1CD6:  MOVWF  x91
1CD8:  CALL   0C1C
....................       printf(lcd_putc," "); 
1CDC:  MOVLW  20
1CDE:  MOVWF  x8F
1CE0:  CALL   0C5C
....................    } 
....................     
....................    IF (CONTADOR_SP == 3) 
1CE4:  MOVF   x6B,W
1CE6:  SUBLW  03
1CE8:  BNZ   1D3A
....................    { 
....................       lcd_gotoxy(10,1); 
1CEA:  MOVLW  0A
1CEC:  MOVWF  x90
1CEE:  MOVLW  01
1CF0:  MOVWF  x91
1CF2:  CALL   0C1C
....................       printf(lcd_putc," "); 
1CF6:  MOVLW  20
1CF8:  MOVWF  x8F
1CFA:  CALL   0C5C
....................       lcd_gotoxy(10,2); 
1CFE:  MOVLW  0A
1D00:  MOVWF  x90
1D02:  MOVLW  02
1D04:  MOVWF  x91
1D06:  CALL   0C1C
....................       printf(lcd_putc," "); 
1D0A:  MOVLW  20
1D0C:  MOVWF  x8F
1D0E:  CALL   0C5C
....................       lcd_gotoxy(10,3); 
1D12:  MOVLW  0A
1D14:  MOVWF  x90
1D16:  MOVLW  03
1D18:  MOVWF  x91
1D1A:  CALL   0C1C
....................       printf(lcd_putc,"<"); 
1D1E:  MOVLW  3C
1D20:  MOVWF  x8F
1D22:  CALL   0C5C
....................       lcd_gotoxy(10,4); 
1D26:  MOVLW  0A
1D28:  MOVWF  x90
1D2A:  MOVLW  04
1D2C:  MOVWF  x91
1D2E:  CALL   0C1C
....................       printf(lcd_putc," "); 
1D32:  MOVLW  20
1D34:  MOVWF  x8F
1D36:  CALL   0C5C
....................    } 
....................    IF (CONTADOR_SP == 4) 
1D3A:  MOVF   x6B,W
1D3C:  SUBLW  04
1D3E:  BNZ   1D90
....................    { 
....................       lcd_gotoxy(10,1); 
1D40:  MOVLW  0A
1D42:  MOVWF  x90
1D44:  MOVLW  01
1D46:  MOVWF  x91
1D48:  CALL   0C1C
....................       printf(lcd_putc," "); 
1D4C:  MOVLW  20
1D4E:  MOVWF  x8F
1D50:  CALL   0C5C
....................       lcd_gotoxy(10,2); 
1D54:  MOVLW  0A
1D56:  MOVWF  x90
1D58:  MOVLW  02
1D5A:  MOVWF  x91
1D5C:  CALL   0C1C
....................       printf(lcd_putc," "); 
1D60:  MOVLW  20
1D62:  MOVWF  x8F
1D64:  CALL   0C5C
....................       lcd_gotoxy(10,3); 
1D68:  MOVLW  0A
1D6A:  MOVWF  x90
1D6C:  MOVLW  03
1D6E:  MOVWF  x91
1D70:  CALL   0C1C
....................       printf(lcd_putc," "); 
1D74:  MOVLW  20
1D76:  MOVWF  x8F
1D78:  CALL   0C5C
....................       lcd_gotoxy(10,4); 
1D7C:  MOVLW  0A
1D7E:  MOVWF  x90
1D80:  MOVLW  04
1D82:  MOVWF  x91
1D84:  CALL   0C1C
....................       printf(lcd_putc,"<"); 
1D88:  MOVLW  3C
1D8A:  MOVWF  x8F
1D8C:  CALL   0C5C
....................    } 
....................    IF (CONTADOR_SP == 5) 
1D90:  MOVF   x6B,W
1D92:  SUBLW  05
1D94:  BNZ   1DE6
....................    { 
....................       lcd_gotoxy(10,1); 
1D96:  MOVLW  0A
1D98:  MOVWF  x90
1D9A:  MOVLW  01
1D9C:  MOVWF  x91
1D9E:  CALL   0C1C
....................       printf(lcd_putc,">"); 
1DA2:  MOVLW  3E
1DA4:  MOVWF  x8F
1DA6:  CALL   0C5C
....................       lcd_gotoxy(10,2); 
1DAA:  MOVLW  0A
1DAC:  MOVWF  x90
1DAE:  MOVLW  02
1DB0:  MOVWF  x91
1DB2:  CALL   0C1C
....................       printf(lcd_putc," "); 
1DB6:  MOVLW  20
1DB8:  MOVWF  x8F
1DBA:  CALL   0C5C
....................       lcd_gotoxy(10,3); 
1DBE:  MOVLW  0A
1DC0:  MOVWF  x90
1DC2:  MOVLW  03
1DC4:  MOVWF  x91
1DC6:  CALL   0C1C
....................       printf(lcd_putc," "); 
1DCA:  MOVLW  20
1DCC:  MOVWF  x8F
1DCE:  CALL   0C5C
....................       lcd_gotoxy(10,4); 
1DD2:  MOVLW  0A
1DD4:  MOVWF  x90
1DD6:  MOVLW  04
1DD8:  MOVWF  x91
1DDA:  CALL   0C1C
....................       printf(lcd_putc," "); 
1DDE:  MOVLW  20
1DE0:  MOVWF  x8F
1DE2:  CALL   0C5C
....................    }       
....................    IF (CONTADOR_SP == 6) 
1DE6:  MOVF   x6B,W
1DE8:  SUBLW  06
1DEA:  BNZ   1E3C
....................    { 
....................       lcd_gotoxy(10,1); 
1DEC:  MOVLW  0A
1DEE:  MOVWF  x90
1DF0:  MOVLW  01
1DF2:  MOVWF  x91
1DF4:  CALL   0C1C
....................       printf(lcd_putc," "); 
1DF8:  MOVLW  20
1DFA:  MOVWF  x8F
1DFC:  CALL   0C5C
....................       lcd_gotoxy(10,2); 
1E00:  MOVLW  0A
1E02:  MOVWF  x90
1E04:  MOVLW  02
1E06:  MOVWF  x91
1E08:  CALL   0C1C
....................       printf(lcd_putc,">"); 
1E0C:  MOVLW  3E
1E0E:  MOVWF  x8F
1E10:  CALL   0C5C
....................       lcd_gotoxy(10,3); 
1E14:  MOVLW  0A
1E16:  MOVWF  x90
1E18:  MOVLW  03
1E1A:  MOVWF  x91
1E1C:  CALL   0C1C
....................       printf(lcd_putc," "); 
1E20:  MOVLW  20
1E22:  MOVWF  x8F
1E24:  CALL   0C5C
....................       lcd_gotoxy(10,4); 
1E28:  MOVLW  0A
1E2A:  MOVWF  x90
1E2C:  MOVLW  04
1E2E:  MOVWF  x91
1E30:  CALL   0C1C
....................       printf(lcd_putc," "); 
1E34:  MOVLW  20
1E36:  MOVWF  x8F
1E38:  CALL   0C5C
....................    } 
....................     
....................    IF (CONTADOR_SP == 7) 
1E3C:  MOVF   x6B,W
1E3E:  SUBLW  07
1E40:  BNZ   1E92
....................    { 
....................       lcd_gotoxy(10,1); 
1E42:  MOVLW  0A
1E44:  MOVWF  x90
1E46:  MOVLW  01
1E48:  MOVWF  x91
1E4A:  CALL   0C1C
....................       printf(lcd_putc," "); 
1E4E:  MOVLW  20
1E50:  MOVWF  x8F
1E52:  CALL   0C5C
....................       lcd_gotoxy(10,2); 
1E56:  MOVLW  0A
1E58:  MOVWF  x90
1E5A:  MOVLW  02
1E5C:  MOVWF  x91
1E5E:  CALL   0C1C
....................       printf(lcd_putc," "); 
1E62:  MOVLW  20
1E64:  MOVWF  x8F
1E66:  CALL   0C5C
....................       lcd_gotoxy(10,3); 
1E6A:  MOVLW  0A
1E6C:  MOVWF  x90
1E6E:  MOVLW  03
1E70:  MOVWF  x91
1E72:  CALL   0C1C
....................       printf(lcd_putc,">"); 
1E76:  MOVLW  3E
1E78:  MOVWF  x8F
1E7A:  CALL   0C5C
....................       lcd_gotoxy(10,4); 
1E7E:  MOVLW  0A
1E80:  MOVWF  x90
1E82:  MOVLW  04
1E84:  MOVWF  x91
1E86:  CALL   0C1C
....................       printf(lcd_putc," "); 
1E8A:  MOVLW  20
1E8C:  MOVWF  x8F
1E8E:  CALL   0C5C
....................    } 
....................    IF (CONTADOR_SP == 8) 
1E92:  MOVF   x6B,W
1E94:  SUBLW  08
1E96:  BNZ   1EE8
....................    { 
....................       lcd_gotoxy(10,1); 
1E98:  MOVLW  0A
1E9A:  MOVWF  x90
1E9C:  MOVLW  01
1E9E:  MOVWF  x91
1EA0:  CALL   0C1C
....................       printf(lcd_putc," "); 
1EA4:  MOVLW  20
1EA6:  MOVWF  x8F
1EA8:  CALL   0C5C
....................       lcd_gotoxy(10,2); 
1EAC:  MOVLW  0A
1EAE:  MOVWF  x90
1EB0:  MOVLW  02
1EB2:  MOVWF  x91
1EB4:  CALL   0C1C
....................       printf(lcd_putc," "); 
1EB8:  MOVLW  20
1EBA:  MOVWF  x8F
1EBC:  CALL   0C5C
....................       lcd_gotoxy(10,3); 
1EC0:  MOVLW  0A
1EC2:  MOVWF  x90
1EC4:  MOVLW  03
1EC6:  MOVWF  x91
1EC8:  CALL   0C1C
....................       printf(lcd_putc," "); 
1ECC:  MOVLW  20
1ECE:  MOVWF  x8F
1ED0:  CALL   0C5C
....................       lcd_gotoxy(10,4); 
1ED4:  MOVLW  0A
1ED6:  MOVWF  x90
1ED8:  MOVLW  04
1EDA:  MOVWF  x91
1EDC:  CALL   0C1C
....................       printf(lcd_putc,">"); 
1EE0:  MOVLW  3E
1EE2:  MOVWF  x8F
1EE4:  CALL   0C5C
....................    } 
.................... } 
1EE8:  BRA    2040
.................... else{IF (CONTADOR_SP == 1) 
1EEA:  DECFSZ x6B,W
1EEC:  BRA    1F3E
....................    { 
....................       lcd_gotoxy(15,1); 
1EEE:  MOVLW  0F
1EF0:  MOVWF  x90
1EF2:  MOVLW  01
1EF4:  MOVWF  x91
1EF6:  CALL   0C1C
....................       printf(lcd_putc,">"); 
1EFA:  MOVLW  3E
1EFC:  MOVWF  x8F
1EFE:  CALL   0C5C
....................       lcd_gotoxy(15,2); 
1F02:  MOVLW  0F
1F04:  MOVWF  x90
1F06:  MOVLW  02
1F08:  MOVWF  x91
1F0A:  CALL   0C1C
....................       printf(lcd_putc," "); 
1F0E:  MOVLW  20
1F10:  MOVWF  x8F
1F12:  CALL   0C5C
....................       lcd_gotoxy(15,3); 
1F16:  MOVLW  0F
1F18:  MOVWF  x90
1F1A:  MOVLW  03
1F1C:  MOVWF  x91
1F1E:  CALL   0C1C
....................       printf(lcd_putc," "); 
1F22:  MOVLW  20
1F24:  MOVWF  x8F
1F26:  CALL   0C5C
....................       lcd_gotoxy(15,4); 
1F2A:  MOVLW  0F
1F2C:  MOVWF  x90
1F2E:  MOVLW  04
1F30:  MOVWF  x91
1F32:  CALL   0C1C
....................       printf(lcd_putc," "); 
1F36:  MOVLW  20
1F38:  MOVWF  x8F
1F3A:  CALL   0C5C
....................    }       
....................    IF (CONTADOR_SP == 2) 
1F3E:  MOVF   x6B,W
1F40:  SUBLW  02
1F42:  BNZ   1F94
....................    { 
....................       lcd_gotoxy(15,1); 
1F44:  MOVLW  0F
1F46:  MOVWF  x90
1F48:  MOVLW  01
1F4A:  MOVWF  x91
1F4C:  CALL   0C1C
....................       printf(lcd_putc," "); 
1F50:  MOVLW  20
1F52:  MOVWF  x8F
1F54:  CALL   0C5C
....................       lcd_gotoxy(15,2); 
1F58:  MOVLW  0F
1F5A:  MOVWF  x90
1F5C:  MOVLW  02
1F5E:  MOVWF  x91
1F60:  CALL   0C1C
....................       printf(lcd_putc,">"); 
1F64:  MOVLW  3E
1F66:  MOVWF  x8F
1F68:  CALL   0C5C
....................       lcd_gotoxy(15,3); 
1F6C:  MOVLW  0F
1F6E:  MOVWF  x90
1F70:  MOVLW  03
1F72:  MOVWF  x91
1F74:  CALL   0C1C
....................       printf(lcd_putc," "); 
1F78:  MOVLW  20
1F7A:  MOVWF  x8F
1F7C:  CALL   0C5C
....................       lcd_gotoxy(15,4); 
1F80:  MOVLW  0F
1F82:  MOVWF  x90
1F84:  MOVLW  04
1F86:  MOVWF  x91
1F88:  CALL   0C1C
....................       printf(lcd_putc," "); 
1F8C:  MOVLW  20
1F8E:  MOVWF  x8F
1F90:  CALL   0C5C
....................    } 
....................     
....................    IF (CONTADOR_SP == 3) 
1F94:  MOVF   x6B,W
1F96:  SUBLW  03
1F98:  BNZ   1FEA
....................    { 
....................       lcd_gotoxy(15,1); 
1F9A:  MOVLW  0F
1F9C:  MOVWF  x90
1F9E:  MOVLW  01
1FA0:  MOVWF  x91
1FA2:  CALL   0C1C
....................       printf(lcd_putc," "); 
1FA6:  MOVLW  20
1FA8:  MOVWF  x8F
1FAA:  CALL   0C5C
....................       lcd_gotoxy(15,2); 
1FAE:  MOVLW  0F
1FB0:  MOVWF  x90
1FB2:  MOVLW  02
1FB4:  MOVWF  x91
1FB6:  CALL   0C1C
....................       printf(lcd_putc," "); 
1FBA:  MOVLW  20
1FBC:  MOVWF  x8F
1FBE:  CALL   0C5C
....................       lcd_gotoxy(15,3); 
1FC2:  MOVLW  0F
1FC4:  MOVWF  x90
1FC6:  MOVLW  03
1FC8:  MOVWF  x91
1FCA:  CALL   0C1C
....................       printf(lcd_putc,">"); 
1FCE:  MOVLW  3E
1FD0:  MOVWF  x8F
1FD2:  CALL   0C5C
....................       lcd_gotoxy(15,4); 
1FD6:  MOVLW  0F
1FD8:  MOVWF  x90
1FDA:  MOVLW  04
1FDC:  MOVWF  x91
1FDE:  CALL   0C1C
....................       printf(lcd_putc," "); 
1FE2:  MOVLW  20
1FE4:  MOVWF  x8F
1FE6:  CALL   0C5C
....................    } 
....................    IF (CONTADOR_SP == 4) 
1FEA:  MOVF   x6B,W
1FEC:  SUBLW  04
1FEE:  BNZ   2040
....................    { 
....................       lcd_gotoxy(15,1); 
1FF0:  MOVLW  0F
1FF2:  MOVWF  x90
1FF4:  MOVLW  01
1FF6:  MOVWF  x91
1FF8:  CALL   0C1C
....................       printf(lcd_putc," "); 
1FFC:  MOVLW  20
1FFE:  MOVWF  x8F
2000:  CALL   0C5C
....................       lcd_gotoxy(15,2); 
2004:  MOVLW  0F
2006:  MOVWF  x90
2008:  MOVLW  02
200A:  MOVWF  x91
200C:  CALL   0C1C
....................       printf(lcd_putc," "); 
2010:  MOVLW  20
2012:  MOVWF  x8F
2014:  CALL   0C5C
....................       lcd_gotoxy(15,3); 
2018:  MOVLW  0F
201A:  MOVWF  x90
201C:  MOVLW  03
201E:  MOVWF  x91
2020:  CALL   0C1C
....................       printf(lcd_putc," "); 
2024:  MOVLW  20
2026:  MOVWF  x8F
2028:  CALL   0C5C
....................       lcd_gotoxy(15,4); 
202C:  MOVLW  0F
202E:  MOVWF  x90
2030:  MOVLW  04
2032:  MOVWF  x91
2034:  CALL   0C1C
....................       printf(lcd_putc,">"); 
2038:  MOVLW  3E
203A:  MOVWF  x8F
203C:  CALL   0C5C
....................    } 
.................... } 
2040:  RETURN 0
.................... } 
....................  
.................... VOID PANTALLA_PROGRAMACION() 
.................... { 
....................    lcd_putc("\f"); 
....................    lcd_gotoxy(1,4); 
....................    printf(lcd_putc,"  MODO PROGRAMACION "); 
....................    delay_ms(1000); 
....................    lcd_gotoxy(1,4); 
....................    printf(lcd_putc,"                     "); 
.................... } 
....................    /* 
.................... Void Teclado(){  
.................... //EN SIMULACION CAMBIO LAS TECLAS AL PTOC     
....................  
....................  
....................          TRIS_IN(); 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //CENTRO  SP (TOGGLE FLAG_CENTRO_SP) / MODO PROGRAMACION 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................                if (bit_test (PORT,4) == 1 ) 
....................           { 
....................           DELAY_MS (50); 
....................             IF (bit_test(PORT,4) == 1 ) 
....................                { 
....................                PANTALLA_PROGRAMACION(); 
....................                FLAG_FIN_SP1 = FLAG_CENTRO_SP;  
....................                FLAG_CENTRO_SP = !FLAG_CENTRO_SP; //XOR 
....................                WHILE (bit_test(PORT,4) == 1 ){} //ESPERA A SOLTAR TECLA 
....................                   IF (PANTALLAS_1 == 1)  //ACOMODA EL CONTADOR SP PARA LAS DISTITAS PANTALLAS                
....................                   { 
....................                   CONTADOR_SP = 1; 
....................                   } 
....................                   IF (PANTALLAS_1 == 2) 
....................                   { 
....................                   CONTADOR_SP = 2; 
....................                   } 
....................                PANTALLAS_SP();  //SIMBOLOGÍA DE MODO DE PROGRAMACION         
....................                }  
....................                IF (FLAG_FIN_SP1 >0) //DETECTA SALIDA DE PROGRAMACION PARA GUARDAR NE EEPROM 
....................                {  
....................                SP(); 
....................                } 
....................           } 
....................    
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //ARRIBA CAMBIO PANTALLA    
.................... /////////////////////////////////////////////////////////////////////////////// 
....................       
....................               if (bit_test(PORT,6) == 1 ) 
....................               { 
....................                   DELAY_MS (50); 
....................                   if (bit_test(PORT,6) == 1 ) 
....................                   { 
....................                      IF (FLAG_CENTRO_SP ==0) //CAMBIA PANTALLA 
....................                      { 
....................                      PANTALLAS_2= PANTALLAS_1; 
....................                      PANTALLAS_1= PANTALLAS_1 -1; 
....................                      if (PANTALLAS_1 <1){ 
....................                      PANTALLAS_1=1;} 
....................                     // WHILE(bit_test(PORT,6) == 1 ){} 
....................                      } 
....................                   } 
....................               } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //ABAJO CAMBIO PANTALLA 
.................... ///////////////////////////////////////////////////////////////////////////////  
....................               if (bit_test(PORT,1) == 1 ) 
....................               { 
....................                   DELAY_MS (50); 
....................                   if (bit_test(PORT,1) == 1 ) 
....................                   { 
....................                     IF (FLAG_CENTRO_SP ==0) 
....................                     { 
....................                         PANTALLAS_2= PANTALLAS_1; 
....................                         PANTALLAS_1= PANTALLAS_1 +1; 
....................                         if (PANTALLAS_1 > 2){ 
....................                         PANTALLAS_1=2;} 
....................                     } 
....................                   } 
....................               }   
....................  
....................  
....................    
.................... /////////////////////////////////////////////////////////////////// 
.................... //ARRIBA CONTADOR SP 
.................... ///////////////////////////////////////////////////////////////////////////////          
....................                IF (bit_test(PORT,6) == 1 )//ARRIBA 
....................                { 
....................                         DELAY_MS (50); 
....................                         IF (bit_test(PORT,6) == 1 )//ARRIBA 
....................                         { 
....................                          IF (FLAG_CENTRO_SP ==1) // DECRE CONTADOR SP 
....................                            { 
....................                                CONTADOR_SP -- ; 
....................                                IF (PANTALLAS_1 == 1) 
....................                                { 
....................                                  IF (CONTADOR_SP <1)  
....................                                  { 
....................                                  CONTADOR_SP = 1; 
....................                                  } 
....................                                } 
....................                                IF (PANTALLAS_1 == 2) 
....................                                { 
....................                                  IF (CONTADOR_SP < 2)  
....................                                  { 
....................                                  CONTADOR_SP = 2; 
....................                                  } 
....................                                } 
....................                            PANTALLAS_SP(); 
....................                            } 
....................                         } 
....................                } 
....................   
.................... ///////////////////////////////////////////////////////////////////////////////            
.................... //ABAJO CONTADOR SP 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................                if (bit_test(PORT,1) == 1 )//ABAJO 
....................                { 
....................                      DELAY_MS (50); 
....................                      if (bit_test(PORT,1) == 1 )//ABAJO 
....................                      { 
....................                         IF (FLAG_CENTRO_SP ==1) 
....................                         { 
....................                            CONTADOR_SP ++ ; 
....................                            IF (PANTALLAS_1 == 1) 
....................                            { 
....................                                  IF (CONTADOR_SP > 4)  
....................                                  { 
....................                                  CONTADOR_SP = 4; 
....................                                  } 
....................                            } 
....................                            IF (PANTALLAS_1 == 2) 
....................                            { 
....................                                  IF (CONTADOR_SP > 3)  
....................                                  { 
....................                                  CONTADOR_SP = 3; 
....................                                  } 
....................                            }      
....................                         PANTALLAS_SP(); 
....................                         } 
....................                      } 
....................                }                   
....................  
....................  
....................                                            
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... // BORRA MARCADORES SP > CUANDO SALE DE MODO DE PROGRAMACION 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................                IF (FLAG_CENTRO_SP ==0)  
....................            { 
....................                         lcd_gotoxy(15,1); 
....................                         printf(lcd_putc," "); 
....................                         lcd_gotoxy(15,2); 
....................                         printf(lcd_putc," "); 
....................                         lcd_gotoxy(15,3); 
....................                         printf(lcd_putc," "); 
....................                         lcd_gotoxy(15,4); 
....................                         printf(lcd_putc," "); 
....................            }          
....................   
....................              
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //IZQUIERDA CONTADOR SP PARA AJUSTAR VALORES A PROGRAMAR 
.................... ///////////////////////////////////////////////////////////////////////////////       
.................... /* 
....................                if (bit_test(PORT,3) == 1 ) 
....................                { 
....................                    DELAY_MS (50); 
....................                    if (bit_test(PORT,3) == 1 ) 
....................                    { 
....................                      IF (FLAG_CENTRO_SP ==1) // DECRE VALOR DE SP 
....................                      { 
....................                        IF (PANTALLAS_1 == 1)/////////////////////////////////////////////PANTALA 1 
....................                        { 
....................                           IF (CONTADOR_SP == 1)//////////////////////////////////// 
....................                            { 
....................                             SP_Z1 = (SP_Z1 -1);IF (SP_Z1 > 300) SP_Z1 = 0; 
....................                             lcd_gotoxy(18,1);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,1);printf(lcd_putc,"%lU" (SP_Z1)); 
....................                            } 
....................                            IF (CONTADOR_SP == 2)//////////////////////////////////// 
....................                            { 
....................                             SP_Z2 = (SP_Z2 -1);IF (SP_Z2 > 300) SP_Z2 = 0; 
....................                             lcd_gotoxy(18,2);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,2);printf(lcd_putc,"%lU" (SP_Z2)); 
....................                            } 
....................                            IF (CONTADOR_SP == 3)//////////////////////////////////// 
....................                            { 
....................                             SP_Z3 = (SP_Z3 -1);IF (SP_Z3 > 300) SP_Z3 = 0; 
....................                             lcd_gotoxy(18,3);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,3);printf(lcd_putc,"%lU" (SP_Z3)); 
....................                            } 
....................                            IF (CONTADOR_SP == 4)//////////////////////////////////// 
....................                            { 
....................                             SP_Z4 = (SP_Z4 -1);IF (SP_Z4 > 300) SP_Z4 = 0; 
....................                             lcd_gotoxy(18,4);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,4);printf(lcd_putc,"%lU" (SP_Z4)); 
....................                            } 
....................                       } 
....................                        IF (PANTALLAS_1 == 2)/////////////////////////////////////////////PANTALA 2 
....................                       { 
....................                            IF (CONTADOR_SP == 2)//////////////////////////////////// 
....................                             { 
....................                             SP_T_MOT = (SP_T_MOT -1);IF (SP_T_MOT > 300) SP_T_MOT = 0; 
....................                             lcd_gotoxy(18,2);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,2);printf(lcd_putc,"%lU" (SP_T_MOT));                           
....................                             } 
....................                            IF (CONTADOR_SP == 3)//////////////////////////////////// 
....................                             { 
....................                             SP_I_MOT = (SP_I_MOT -1);IF (SP_I_MOT > 300) SP_I_MOT = 0; 
....................                             lcd_gotoxy(18,3);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,3);printf(lcd_putc,"%lU" (SP_I_MOT));                         
....................                             } 
....................                       } 
....................                      } 
....................                    } 
....................                } 
....................  
....................  
....................                if (bit_test(PORT,3) == 1 ) 
....................                { 
....................                    DELAY_MS (50); 
....................                    if (bit_test(PORT,3) == 1 ) 
....................                    { 
....................                      IF (FLAG_CENTRO_SP ==1) // DECRE VALOR DE SP 
....................                      { 
....................                        IF (PANTALLAS_1 == 1)/////////////////////////////////////////////PANTALA 1 
....................                        { 
....................                           IF (CONTADOR_SP == 1)//////////////////////////////////// 
....................                            { 
....................                             SP_Z1 = 0; 
....................                             lcd_gotoxy(18,1);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,1);printf(lcd_putc,"%lU" (SP_Z1)); 
....................                            } 
....................                            IF (CONTADOR_SP == 2)//////////////////////////////////// 
....................                            { 
....................                             SP_Z2= 0; 
....................                             lcd_gotoxy(18,2);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,2);printf(lcd_putc,"%lU" (SP_Z2)); 
....................                            } 
....................                            IF (CONTADOR_SP == 3)//////////////////////////////////// 
....................                            { 
....................                             SP_Z3  = 0; 
....................                             lcd_gotoxy(18,3);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,3);printf(lcd_putc,"%lU" (SP_Z3)); 
....................                            } 
....................                            IF (CONTADOR_SP == 4)//////////////////////////////////// 
....................                            { 
....................                             SP_Z4 =0; 
....................                             lcd_gotoxy(18,4);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,4);printf(lcd_putc,"%lU" (SP_Z4)); 
....................                            } 
....................                       } 
....................                        IF (PANTALLAS_1 == 2)/////////////////////////////////////////////PANTALA 2 
....................                       { 
....................                            IF (CONTADOR_SP == 2)//////////////////////////////////// 
....................                             { 
....................                             SP_T_MOT =   0; 
....................                             lcd_gotoxy(18,2);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,2);printf(lcd_putc,"%lU" (SP_T_MOT));                           
....................                             } 
....................                            IF (CONTADOR_SP == 3)//////////////////////////////////// 
....................                             { 
....................                             SP_I_MOT =  0; 
....................                             lcd_gotoxy(18,3);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,3);printf(lcd_putc,"%lU" (SP_I_MOT));                         
....................                             } 
....................                       } 
....................                      } 
....................                    } 
....................                } 
....................                           
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //DERECHA CONTADOR SP PARA AJUSTAR VALORES A PROGRAMAR 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................                if (bit_test(PORT,5) == 1 ) 
....................                { 
....................                    DELAY_MS (50); 
....................                    if (bit_test(PORT,5) == 1 ) 
....................                    { 
....................                      IF (FLAG_CENTRO_SP ==1) // INCRE VALOS DE SP 
....................                      { 
....................                        IF (PANTALLAS_1 == 1)/////////////////////////////////////////////PANTALA 1 
....................                          { 
....................                            IF (CONTADOR_SP == 1)//////////////////////////////////// 
....................                            { 
....................                             SP_Z1 = (SP_Z1 + 1);IF (SP_Z1 > 300) SP_Z1 = 300; 
....................                             lcd_gotoxy(18,1);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,1);printf(lcd_putc,"%lU" (SP_Z1));                           
....................                            } 
....................                            IF (CONTADOR_SP == 2)//////////////////////////////////// 
....................                            { 
....................                             SP_Z2 = (SP_Z2 + 1);IF (SP_Z2 > 300) SP_Z2 = 300; 
....................                             lcd_gotoxy(18,2);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,2);printf(lcd_putc,"%lU" (SP_Z2));                            
....................                            } 
....................                            IF (CONTADOR_SP == 3)//////////////////////////////////// 
....................                            { 
....................                             SP_Z3 = (SP_Z3 + 1);IF (SP_Z3 > 300) SP_Z3 = 300; 
....................                             lcd_gotoxy(18,3);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,3);printf(lcd_putc,"%lU" (SP_Z3));                          
....................                            } 
....................                            IF (CONTADOR_SP == 4)//////////////////////////////////// 
....................                            { 
....................                             SP_Z4 = (SP_Z4 + 1);IF (SP_Z4 > 300) SP_Z4 = 300; 
....................                             lcd_gotoxy(18,4);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,4);printf(lcd_putc,"%lU" (SP_Z4));  
....................                            } 
....................                         } 
....................                        IF (PANTALLAS_1 == 2)/////////////////////////////////////////////PANTALA 2 
....................                       { 
....................                            IF (CONTADOR_SP == 2)//////////////////////////////////// 
....................                             { 
....................                             SP_T_MOT = (SP_T_MOT + 1);IF (SP_T_MOT > 300) SP_T_MOT = 300; 
....................                             lcd_gotoxy(18,2);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,2);printf(lcd_putc,"%lU" (SP_T_MOT));                            
....................                             } 
....................                            IF (CONTADOR_SP == 3)//////////////////////////////////// 
....................                             { 
....................                             SP_I_MOT = (SP_I_MOT + 1);IF (SP_I_MOT > 300) SP_I_MOT = 300; 
....................                             lcd_gotoxy(18,3);printf(lcd_putc,"   ");  
....................                             lcd_gotoxy(18,3);printf(lcd_putc,"%lU" (SP_I_MOT));                          
....................                             } 
....................                        } 
....................                         
....................                      } 
....................                    } 
....................                }  
....................  
.................... //TEMPORAL//////////////////////////////////////////////////////////////////////////////// 
.................... /* 
....................            IF (FLAG_CENTRO_SP ==1) 
....................            { 
....................            lcd_gotoxy(20,1); 
....................            printf(lcd_putc,"%i" ((CONTADOR_SP))); 
....................            lcd_gotoxy(20,2); 
....................            printf(lcd_putc,"%i" ((FLAG_CENTRO_SP))); 
....................            } 
....................            ELSE 
....................            { 
....................            lcd_gotoxy(20,1); 
....................            printf(lcd_putc," "); 
....................            //lcd_gotoxy(20,2); 
....................            //printf(lcd_putc," "); 
....................            } 
....................            lcd_gotoxy(20,2); 
....................            printf(lcd_putc,"%i" ((FLAG_CENTRO_SP))); 
....................            //lcd_gotoxy(20,3); 
....................            //printf(lcd_putc,"%i" ((PANTALLAS_1))); 
....................            lcd_gotoxy(1,14); 
....................            printf(lcd_putc,"%i" ((PANTALLAS_1))); 
....................        
....................            Lcd_gotoxy(1,14); 
....................            printf(lcd_putc,"%i" ((CONTADOR_SP))); 
....................             
....................             
.................... //TRISB SALIDAS 
....................           bit_CLEAR(TRISB,1); 
....................           bit_CLEAR(TRISB,3);  
....................           bit_CLEAR(TRISB,4);  
....................           bit_CLEAR(TRISB,5);  
....................           bit_CLEAR(TRISB,6);  
....................           delay_ms(20); 
....................   
....................   
.................... } 
....................  
.................... */ 
....................  
....................  
....................  
.................... #include<Pantallas.c> 
.................... Void pantalla_0_fija(){  
....................  
....................  
....................  
....................  
....................        
....................  
....................    //lcd_putc("\f"); 
....................     
....................       lcd_gotoxy(18,4); 
*
10B8:  MOVLW  12
10BA:  MOVWF  x90
10BC:  MOVLW  04
10BE:  MOVWF  x91
10C0:  RCALL  0C1C
....................       printf(lcd_putc,"   "); 
10C2:  MOVLW  E2
10C4:  MOVWF  FF6
10C6:  MOVLW  00
10C8:  MOVWF  FF7
10CA:  RCALL  0CA4
....................       lcd_gotoxy(18,4); 
10CC:  MOVLW  12
10CE:  MOVWF  x90
10D0:  MOVLW  04
10D2:  MOVWF  x91
10D4:  RCALL  0C1C
....................       printf(lcd_putc,"%lU" (SP_Z4)); 
10D6:  MOVLW  10
10D8:  MOVWF  FE9
10DA:  MOVFF  4C,83
10DE:  MOVFF  4B,82
10E2:  RCALL  0D5C
....................        
....................       lcd_gotoxy(18,3); 
10E4:  MOVLW  12
10E6:  MOVWF  x90
10E8:  MOVLW  03
10EA:  MOVWF  x91
10EC:  RCALL  0C1C
....................       printf(lcd_putc,"   "); 
10EE:  MOVLW  E6
10F0:  MOVWF  FF6
10F2:  MOVLW  00
10F4:  MOVWF  FF7
10F6:  RCALL  0CA4
....................       lcd_gotoxy(18,3); 
10F8:  MOVLW  12
10FA:  MOVWF  x90
10FC:  MOVLW  03
10FE:  MOVWF  x91
1100:  RCALL  0C1C
....................       printf(lcd_putc,"%lU" (SP_Z3)); 
1102:  MOVLW  10
1104:  MOVWF  FE9
1106:  MOVFF  4A,83
110A:  MOVFF  49,82
110E:  RCALL  0D5C
....................  
....................       lcd_gotoxy(18,2); 
1110:  MOVLW  12
1112:  MOVWF  x90
1114:  MOVLW  02
1116:  MOVWF  x91
1118:  RCALL  0C1C
....................       printf(lcd_putc,"   "); 
111A:  MOVLW  EA
111C:  MOVWF  FF6
111E:  MOVLW  00
1120:  MOVWF  FF7
1122:  RCALL  0CA4
....................       lcd_gotoxy(18,2); 
1124:  MOVLW  12
1126:  MOVWF  x90
1128:  MOVLW  02
112A:  MOVWF  x91
112C:  RCALL  0C1C
....................       printf(lcd_putc,"%lU" (SP_Z2)); 
112E:  MOVLW  10
1130:  MOVWF  FE9
1132:  MOVFF  48,83
1136:  MOVFF  47,82
113A:  RCALL  0D5C
....................        
....................       lcd_gotoxy(18,1); 
113C:  MOVLW  12
113E:  MOVWF  x90
1140:  MOVLW  01
1142:  MOVWF  x91
1144:  RCALL  0C1C
....................       printf(lcd_putc,"   "); 
1146:  MOVLW  EE
1148:  MOVWF  FF6
114A:  MOVLW  00
114C:  MOVWF  FF7
114E:  RCALL  0CA4
....................       lcd_gotoxy(18,1); 
1150:  MOVLW  12
1152:  MOVWF  x90
1154:  MOVLW  01
1156:  MOVWF  x91
1158:  RCALL  0C1C
....................       printf(lcd_putc,"%lU" (SP_Z1)); 
115A:  MOVLW  10
115C:  MOVWF  FE9
115E:  MOVFF  46,83
1162:  MOVFF  45,82
1166:  RCALL  0D5C
....................       
....................    lcd_gotoxy(1,1); 
1168:  MOVLW  01
116A:  MOVWF  x90
116C:  MOVWF  x91
116E:  RCALL  0C1C
....................    printf(lcd_putc,"Z1:"); 
1170:  MOVLW  F2
1172:  MOVWF  FF6
1174:  MOVLW  00
1176:  MOVWF  FF7
1178:  RCALL  0CA4
....................    lcd_gotoxy(1,2); 
117A:  MOVLW  01
117C:  MOVWF  x90
117E:  MOVLW  02
1180:  MOVWF  x91
1182:  RCALL  0C1C
....................    printf(lcd_putc,"Z2:");   
1184:  MOVLW  F6
1186:  MOVWF  FF6
1188:  MOVLW  00
118A:  MOVWF  FF7
118C:  RCALL  0CA4
....................    lcd_gotoxy(1,3); 
118E:  MOVLW  01
1190:  MOVWF  x90
1192:  MOVLW  03
1194:  MOVWF  x91
1196:  RCALL  0C1C
....................    printf(lcd_putc,"Z3:"); 
1198:  MOVLW  FA
119A:  MOVWF  FF6
119C:  MOVLW  00
119E:  MOVWF  FF7
11A0:  RCALL  0CA4
....................    lcd_gotoxy(1,4); 
11A2:  MOVLW  01
11A4:  MOVWF  x90
11A6:  MOVLW  04
11A8:  MOVWF  x91
11AA:  RCALL  0C1C
....................    printf(lcd_putc,"Z4:"); 
11AC:  MOVLW  FE
11AE:  MOVWF  FF6
11B0:  MOVLW  00
11B2:  MOVWF  FF7
11B4:  RCALL  0CA4
....................    lcd_gotoxy(16,1); 
11B6:  MOVLW  10
11B8:  MOVWF  x90
11BA:  MOVLW  01
11BC:  MOVWF  x91
11BE:  RCALL  0C1C
....................    printf(lcd_putc,"SP");  
11C0:  MOVLW  53
11C2:  MOVWF  x8F
11C4:  RCALL  0C5C
11C6:  MOVLW  50
11C8:  MOVWF  x8F
11CA:  RCALL  0C5C
....................    lcd_gotoxy(16,2); 
11CC:  MOVLW  10
11CE:  MOVWF  x90
11D0:  MOVLW  02
11D2:  MOVWF  x91
11D4:  RCALL  0C1C
....................    printf(lcd_putc,"SP"); 
11D6:  MOVLW  53
11D8:  MOVWF  x8F
11DA:  RCALL  0C5C
11DC:  MOVLW  50
11DE:  MOVWF  x8F
11E0:  RCALL  0C5C
....................    lcd_gotoxy(16,3); 
11E2:  MOVLW  10
11E4:  MOVWF  x90
11E6:  MOVLW  03
11E8:  MOVWF  x91
11EA:  RCALL  0C1C
....................    printf(lcd_putc,"SP"); 
11EC:  MOVLW  53
11EE:  MOVWF  x8F
11F0:  RCALL  0C5C
11F2:  MOVLW  50
11F4:  MOVWF  x8F
11F6:  RCALL  0C5C
....................    lcd_gotoxy(16,4); 
11F8:  MOVLW  10
11FA:  MOVWF  x90
11FC:  MOVLW  04
11FE:  MOVWF  x91
1200:  RCALL  0C1C
....................    printf(lcd_putc,"SP");  
1202:  MOVLW  53
1204:  MOVWF  x8F
1206:  RCALL  0C5C
1208:  MOVLW  50
120A:  MOVWF  x8F
120C:  RCALL  0C5C
....................     
....................    //MUESTRA Z1 
....................    lcd_gotoxy(4,1); 
120E:  MOVLW  04
1210:  MOVWF  x90
1212:  MOVLW  01
1214:  MOVWF  x91
1216:  RCALL  0C1C
....................    printf(lcd_putc,"       "); 
1218:  MOVLW  02
121A:  MOVWF  FF6
121C:  MOVLW  01
121E:  MOVWF  FF7
1220:  RCALL  0CA4
....................    lcd_gotoxy(4,1); 
1222:  MOVLW  04
1224:  MOVWF  x90
1226:  MOVLW  01
1228:  MOVWF  x91
122A:  RCALL  0C1C
....................    printf(lcd_putc, "%4.0g", (Temp_Z1)); 
122C:  MOVLW  03
122E:  MOVWF  FE9
1230:  MOVFF  32,85
1234:  MOVFF  31,84
1238:  MOVFF  30,83
123C:  MOVFF  2F,82
1240:  CLRF   x86
1242:  RCALL  0EE4
....................    printf(lcd_putc,"%c" (223)); 
1244:  MOVLW  DF
1246:  MOVWF  x8F
1248:  RCALL  0C5C
....................    printf(lcd_putc, "C"); 
124A:  MOVLW  43
124C:  MOVWF  x8F
124E:  RCALL  0C5C
....................     
....................    //MUESTRA Z2 
....................    lcd_gotoxy(4,2); 
1250:  MOVLW  04
1252:  MOVWF  x90
1254:  MOVLW  02
1256:  MOVWF  x91
1258:  RCALL  0C1C
....................    printf(lcd_putc,"       "); 
125A:  MOVLW  0A
125C:  MOVWF  FF6
125E:  MOVLW  01
1260:  MOVWF  FF7
1262:  RCALL  0CA4
....................    lcd_gotoxy(4,2); 
1264:  MOVLW  04
1266:  MOVWF  x90
1268:  MOVLW  02
126A:  MOVWF  x91
126C:  RCALL  0C1C
126E:  CLRF   16
1270:  BTFSC  FF2.7
1272:  BSF    16.7
1274:  BCF    FF2.7
....................    if(Temp_Z2<999) 
1276:  MOVFF  36,A2
127A:  MOVFF  35,A1
127E:  MOVFF  34,A0
1282:  MOVFF  33,9F
1286:  CLRF   xA6
1288:  MOVLW  C0
128A:  MOVWF  xA5
128C:  MOVLW  79
128E:  MOVWF  xA4
1290:  MOVLW  88
1292:  MOVWF  xA3
1294:  CALL   07C4
1298:  BTFSC  16.7
129A:  BSF    FF2.7
129C:  BNC   12B6
....................    printf(lcd_putc, "%4.0g", (Temp_Z2)); 
129E:  MOVLW  03
12A0:  MOVWF  FE9
12A2:  MOVFF  36,85
12A6:  MOVFF  35,84
12AA:  MOVFF  34,83
12AE:  MOVFF  33,82
12B2:  CLRF   x86
12B4:  RCALL  0EE4
....................    printf(lcd_putc,"%c" (223)); 
12B6:  MOVLW  DF
12B8:  MOVWF  x8F
12BA:  RCALL  0C5C
....................    printf(lcd_putc, "C"); 
12BC:  MOVLW  43
12BE:  MOVWF  x8F
12C0:  RCALL  0C5C
....................     
....................    //MUESTRA Z3 
....................    lcd_gotoxy(4,3); 
12C2:  MOVLW  04
12C4:  MOVWF  x90
12C6:  MOVLW  03
12C8:  MOVWF  x91
12CA:  RCALL  0C1C
....................    printf(lcd_putc,"       "); 
12CC:  MOVLW  12
12CE:  MOVWF  FF6
12D0:  MOVLW  01
12D2:  MOVWF  FF7
12D4:  RCALL  0CA4
....................    lcd_gotoxy(4,3); 
12D6:  MOVLW  04
12D8:  MOVWF  x90
12DA:  MOVLW  03
12DC:  MOVWF  x91
12DE:  RCALL  0C1C
12E0:  CLRF   16
12E2:  BTFSC  FF2.7
12E4:  BSF    16.7
12E6:  BCF    FF2.7
....................    if(Temp_Z3<999) 
12E8:  MOVFF  3A,A2
12EC:  MOVFF  39,A1
12F0:  MOVFF  38,A0
12F4:  MOVFF  37,9F
12F8:  CLRF   xA6
12FA:  MOVLW  C0
12FC:  MOVWF  xA5
12FE:  MOVLW  79
1300:  MOVWF  xA4
1302:  MOVLW  88
1304:  MOVWF  xA3
1306:  CALL   07C4
130A:  BTFSC  16.7
130C:  BSF    FF2.7
130E:  BNC   1328
....................    printf(lcd_putc, "%4.0g", (Temp_Z3)); 
1310:  MOVLW  03
1312:  MOVWF  FE9
1314:  MOVFF  3A,85
1318:  MOVFF  39,84
131C:  MOVFF  38,83
1320:  MOVFF  37,82
1324:  CLRF   x86
1326:  RCALL  0EE4
....................    printf(lcd_putc,"%c" (223)); 
1328:  MOVLW  DF
132A:  MOVWF  x8F
132C:  RCALL  0C5C
....................    printf(lcd_putc, "C"); 
132E:  MOVLW  43
1330:  MOVWF  x8F
1332:  RCALL  0C5C
....................  
....................     
....................    //MUESTRA Z4 
....................    lcd_gotoxy(4,4); 
1334:  MOVLW  04
1336:  MOVWF  x90
1338:  MOVWF  x91
133A:  RCALL  0C1C
....................    printf(lcd_putc,"       "); 
133C:  MOVLW  1A
133E:  MOVWF  FF6
1340:  MOVLW  01
1342:  MOVWF  FF7
1344:  RCALL  0CA4
....................    lcd_gotoxy(4,4); 
1346:  MOVLW  04
1348:  MOVWF  x90
134A:  MOVWF  x91
134C:  RCALL  0C1C
134E:  CLRF   16
1350:  BTFSC  FF2.7
1352:  BSF    16.7
1354:  BCF    FF2.7
....................    if(Temp_Z4<999) 
1356:  MOVFF  3E,A2
135A:  MOVFF  3D,A1
135E:  MOVFF  3C,A0
1362:  MOVFF  3B,9F
1366:  CLRF   xA6
1368:  MOVLW  C0
136A:  MOVWF  xA5
136C:  MOVLW  79
136E:  MOVWF  xA4
1370:  MOVLW  88
1372:  MOVWF  xA3
1374:  CALL   07C4
1378:  BTFSC  16.7
137A:  BSF    FF2.7
137C:  BNC   1396
....................    printf(lcd_putc, "%4.0g", (Temp_Z4)); 
137E:  MOVLW  03
1380:  MOVWF  FE9
1382:  MOVFF  3E,85
1386:  MOVFF  3D,84
138A:  MOVFF  3C,83
138E:  MOVFF  3B,82
1392:  CLRF   x86
1394:  RCALL  0EE4
....................    printf(lcd_putc,"%c" (223)); 
1396:  MOVLW  DF
1398:  MOVWF  x8F
139A:  RCALL  0C5C
....................    printf(lcd_putc, "C"); 
139C:  MOVLW  43
139E:  MOVWF  x8F
13A0:  RCALL  0C5C
13A2:  RETURN 0
....................     
.................... } 
....................  
.................... Void pantalla_1_fija(){ 
....................  
....................    //lcd_putc("\f"); 
....................           lcd_gotoxy(18,2); 
*
1448:  MOVLW  12
144A:  MOVWF  x90
144C:  MOVLW  02
144E:  MOVWF  x91
1450:  CALL   0C1C
....................       printf(lcd_putc,"   "); 
1454:  MOVLW  22
1456:  MOVWF  FF6
1458:  MOVLW  01
145A:  MOVWF  FF7
145C:  RCALL  0CA4
....................       lcd_gotoxy(18,2); 
145E:  MOVLW  12
1460:  MOVWF  x90
1462:  MOVLW  02
1464:  MOVWF  x91
1466:  CALL   0C1C
....................       printf(lcd_putc,"%lU" (SP_T_MOT)); 
146A:  MOVLW  10
146C:  MOVWF  FE9
146E:  MOVFF  50,83
1472:  MOVFF  4F,82
1476:  RCALL  0D5C
....................  
....................       lcd_gotoxy(18,3); 
1478:  MOVLW  12
147A:  MOVWF  x90
147C:  MOVLW  03
147E:  MOVWF  x91
1480:  CALL   0C1C
....................       printf(lcd_putc,"   "); 
1484:  MOVLW  26
1486:  MOVWF  FF6
1488:  MOVLW  01
148A:  MOVWF  FF7
148C:  RCALL  0CA4
....................       lcd_gotoxy(18,3); 
148E:  MOVLW  12
1490:  MOVWF  x90
1492:  MOVLW  03
1494:  MOVWF  x91
1496:  CALL   0C1C
....................       printf(lcd_putc,"%lU" (SP_I_MOT)); 
149A:  MOVLW  10
149C:  MOVWF  FE9
149E:  MOVFF  4E,83
14A2:  MOVFF  4D,82
14A6:  RCALL  0D5C
....................  
....................    lcd_gotoxy(1,1); 
14A8:  MOVLW  01
14AA:  MOVWF  x90
14AC:  MOVWF  x91
14AE:  CALL   0C1C
....................    printf(lcd_putc,"T_AMB:"); 
14B2:  MOVLW  2A
14B4:  MOVWF  FF6
14B6:  MOVLW  01
14B8:  MOVWF  FF7
14BA:  CALL   0CA4
....................    lcd_gotoxy(1,2); 
14BE:  MOVLW  01
14C0:  MOVWF  x90
14C2:  MOVLW  02
14C4:  MOVWF  x91
14C6:  CALL   0C1C
....................    printf(lcd_putc,"T_MOT:"); 
14CA:  MOVLW  32
14CC:  MOVWF  FF6
14CE:  MOVLW  01
14D0:  MOVWF  FF7
14D2:  CALL   0CA4
....................    lcd_gotoxy(1,3); 
14D6:  MOVLW  01
14D8:  MOVWF  x90
14DA:  MOVLW  03
14DC:  MOVWF  x91
14DE:  CALL   0C1C
....................    printf(lcd_putc,"I_MOT:"); 
14E2:  MOVLW  3A
14E4:  MOVWF  FF6
14E6:  MOVLW  01
14E8:  MOVWF  FF7
14EA:  CALL   0CA4
....................    lcd_gotoxy(1,4); 
14EE:  MOVLW  01
14F0:  MOVWF  x90
14F2:  MOVLW  04
14F4:  MOVWF  x91
14F6:  CALL   0C1C
....................    printf(lcd_putc,"RPM :"); 
14FA:  MOVLW  42
14FC:  MOVWF  FF6
14FE:  MOVLW  01
1500:  MOVWF  FF7
1502:  CALL   0CA4
....................     
....................    lcd_gotoxy(16,3); 
1506:  MOVLW  10
1508:  MOVWF  x90
150A:  MOVLW  03
150C:  MOVWF  x91
150E:  CALL   0C1C
....................    printf(lcd_putc,"SP"); 
1512:  MOVLW  53
1514:  MOVWF  x8F
1516:  CALL   0C5C
151A:  MOVLW  50
151C:  MOVWF  x8F
151E:  CALL   0C5C
....................     
....................     
....................    //NUESTRA TEMP_AMB   
....................    lcd_gotoxy(7,1); 
1522:  MOVLW  07
1524:  MOVWF  x90
1526:  MOVLW  01
1528:  MOVWF  x91
152A:  CALL   0C1C
....................    printf(lcd_putc,"    "); 
152E:  MOVLW  48
1530:  MOVWF  FF6
1532:  MOVLW  01
1534:  MOVWF  FF7
1536:  CALL   0CA4
....................    lcd_gotoxy(7,1); 
153A:  MOVLW  07
153C:  MOVWF  x90
153E:  MOVLW  01
1540:  MOVWF  x91
1542:  CALL   0C1C
....................    printf(lcd_putc,"%lu" (Temp_Amb)); 
1546:  MOVLW  10
1548:  MOVWF  FE9
154A:  MOVFF  42,83
154E:  MOVFF  41,82
1552:  RCALL  0D5C
....................    lcd_gotoxy(9,1); 
1554:  MOVLW  09
1556:  MOVWF  x90
1558:  MOVLW  01
155A:  MOVWF  x91
155C:  CALL   0C1C
....................    printf(lcd_putc,"%c" (223)); 
1560:  MOVLW  DF
1562:  MOVWF  x8F
1564:  CALL   0C5C
....................     
....................    lcd_gotoxy(10,1); 
1568:  MOVLW  0A
156A:  MOVWF  x90
156C:  MOVLW  01
156E:  MOVWF  x91
1570:  CALL   0C1C
....................    printf(lcd_putc,"AD"); 
1574:  MOVLW  41
1576:  MOVWF  x8F
1578:  CALL   0C5C
157C:  MOVLW  44
157E:  MOVWF  x8F
1580:  CALL   0C5C
....................    lcd_gotoxy(12,1); 
1584:  MOVLW  0C
1586:  MOVWF  x90
1588:  MOVLW  01
158A:  MOVWF  x91
158C:  CALL   0C1C
....................    printf(lcd_putc,"    "); 
1590:  MOVLW  4E
1592:  MOVWF  FF6
1594:  MOVLW  01
1596:  MOVWF  FF7
1598:  CALL   0CA4
....................    lcd_gotoxy(12,1); 
159C:  MOVLW  0C
159E:  MOVWF  x90
15A0:  MOVLW  01
15A2:  MOVWF  x91
15A4:  CALL   0C1C
....................    printf(lcd_putc,"%lu" (ADC_TEMPERATURA_AMBIENTE)); 
15A8:  MOVLW  41
15AA:  MOVWF  FE9
15AC:  MOVFF  2A,85
15B0:  MOVFF  29,84
15B4:  MOVFF  28,83
15B8:  MOVFF  27,82
15BC:  RCALL  13A4
....................     
....................     
....................    //MUESTRA TEMP MOTOR 
....................     
....................    lcd_gotoxy(7,2); 
15BE:  MOVLW  07
15C0:  MOVWF  x90
15C2:  MOVLW  02
15C4:  MOVWF  x91
15C6:  CALL   0C1C
....................    printf(lcd_putc,"    "); 
15CA:  MOVLW  54
15CC:  MOVWF  FF6
15CE:  MOVLW  01
15D0:  MOVWF  FF7
15D2:  CALL   0CA4
....................    lcd_gotoxy(7,2); 
15D6:  MOVLW  07
15D8:  MOVWF  x90
15DA:  MOVLW  02
15DC:  MOVWF  x91
15DE:  CALL   0C1C
....................    printf(lcd_putc,"%lu" (Temp_Mot));  
15E2:  MOVLW  10
15E4:  MOVWF  FE9
15E6:  MOVFF  40,83
15EA:  MOVFF  3F,82
15EE:  CALL   0D5C
....................    lcd_gotoxy(9,1); 
15F2:  MOVLW  09
15F4:  MOVWF  x90
15F6:  MOVLW  01
15F8:  MOVWF  x91
15FA:  CALL   0C1C
....................    printf(lcd_putc,"%c" (223)); 
15FE:  MOVLW  DF
1600:  MOVWF  x8F
1602:  CALL   0C5C
....................    lcd_gotoxy(10,2); 
1606:  MOVLW  0A
1608:  MOVWF  x90
160A:  MOVLW  02
160C:  MOVWF  x91
160E:  CALL   0C1C
....................    printf(lcd_putc,"AD"); 
1612:  MOVLW  41
1614:  MOVWF  x8F
1616:  CALL   0C5C
161A:  MOVLW  44
161C:  MOVWF  x8F
161E:  CALL   0C5C
....................    lcd_gotoxy(12,2); 
1622:  MOVLW  0C
1624:  MOVWF  x90
1626:  MOVLW  02
1628:  MOVWF  x91
162A:  CALL   0C1C
....................    printf(lcd_putc,"    "); 
162E:  MOVLW  5A
1630:  MOVWF  FF6
1632:  MOVLW  01
1634:  MOVWF  FF7
1636:  CALL   0CA4
....................    lcd_gotoxy(12,2); 
163A:  MOVLW  0C
163C:  MOVWF  x90
163E:  MOVLW  02
1640:  MOVWF  x91
1642:  CALL   0C1C
....................    printf(lcd_putc,"%lu" (ADC_TEMPERATURA_MOTOR)); 
1646:  MOVLW  41
1648:  MOVWF  FE9
164A:  MOVFF  2E,85
164E:  MOVFF  2D,84
1652:  MOVFF  2C,83
1656:  MOVFF  2B,82
165A:  RCALL  13A4
....................    lcd_gotoxy(16,2); 
165C:  MOVLW  10
165E:  MOVWF  x90
1660:  MOVLW  02
1662:  MOVWF  x91
1664:  CALL   0C1C
....................    printf(lcd_putc,"SP"); 
1668:  MOVLW  53
166A:  MOVWF  x8F
166C:  CALL   0C5C
1670:  MOVLW  50
1672:  MOVWF  x8F
1674:  CALL   0C5C
1678:  RETURN 0
....................  
....................    } 
....................     
.................... Void pantalla_2_fija(){ 
....................    // lcd_putc("\f"); 
....................      
....................     lcd_gotoxy(1,1); 
167A:  MOVLW  01
167C:  MOVWF  x90
167E:  MOVWF  x91
1680:  CALL   0C1C
....................     printf(lcd_putc,"OfZ1:"); 
1684:  MOVLW  60
1686:  MOVWF  FF6
1688:  MOVLW  01
168A:  MOVWF  FF7
168C:  CALL   0CA4
....................     lcd_gotoxy(1,2); 
1690:  MOVLW  01
1692:  MOVWF  x90
1694:  MOVLW  02
1696:  MOVWF  x91
1698:  CALL   0C1C
....................     printf(lcd_putc,"OfZ2:"); 
169C:  MOVLW  66
169E:  MOVWF  FF6
16A0:  MOVLW  01
16A2:  MOVWF  FF7
16A4:  CALL   0CA4
....................     lcd_gotoxy(1,3); 
16A8:  MOVLW  01
16AA:  MOVWF  x90
16AC:  MOVLW  03
16AE:  MOVWF  x91
16B0:  CALL   0C1C
....................     printf(lcd_putc,"OfZ3:"); 
16B4:  MOVLW  6C
16B6:  MOVWF  FF6
16B8:  MOVLW  01
16BA:  MOVWF  FF7
16BC:  CALL   0CA4
....................     lcd_gotoxy(1,4); 
16C0:  MOVLW  01
16C2:  MOVWF  x90
16C4:  MOVLW  04
16C6:  MOVWF  x91
16C8:  CALL   0C1C
....................     printf(lcd_putc,"OfZ4:"); 
16CC:  MOVLW  72
16CE:  MOVWF  FF6
16D0:  MOVLW  01
16D2:  MOVWF  FF7
16D4:  CALL   0CA4
....................      
....................     lcd_gotoxy(11,1); 
16D8:  MOVLW  0B
16DA:  MOVWF  x90
16DC:  MOVLW  01
16DE:  MOVWF  x91
16E0:  CALL   0C1C
....................     printf(lcd_putc,"MaxZ1:"); 
16E4:  MOVLW  78
16E6:  MOVWF  FF6
16E8:  MOVLW  01
16EA:  MOVWF  FF7
16EC:  CALL   0CA4
....................     lcd_gotoxy(11,2); 
16F0:  MOVLW  0B
16F2:  MOVWF  x90
16F4:  MOVLW  02
16F6:  MOVWF  x91
16F8:  CALL   0C1C
....................     printf(lcd_putc,"MaxZ2:"); 
16FC:  MOVLW  80
16FE:  MOVWF  FF6
1700:  MOVLW  01
1702:  MOVWF  FF7
1704:  CALL   0CA4
....................     lcd_gotoxy(11,3); 
1708:  MOVLW  0B
170A:  MOVWF  x90
170C:  MOVLW  03
170E:  MOVWF  x91
1710:  CALL   0C1C
....................     printf(lcd_putc,"MaxZ3:"); 
1714:  MOVLW  88
1716:  MOVWF  FF6
1718:  MOVLW  01
171A:  MOVWF  FF7
171C:  CALL   0CA4
....................     lcd_gotoxy(11,4); 
1720:  MOVLW  0B
1722:  MOVWF  x90
1724:  MOVLW  04
1726:  MOVWF  x91
1728:  CALL   0C1C
....................     printf(lcd_putc,"MaxZ4:"); 
172C:  MOVLW  90
172E:  MOVWF  FF6
1730:  MOVLW  01
1732:  MOVWF  FF7
1734:  CALL   0CA4
....................      
....................     lcd_gotoxy(6,1); 
1738:  MOVLW  06
173A:  MOVWF  x90
173C:  MOVLW  01
173E:  MOVWF  x91
1740:  CALL   0C1C
....................       printf(lcd_putc,"    "); 
1744:  MOVLW  98
1746:  MOVWF  FF6
1748:  MOVLW  01
174A:  MOVWF  FF7
174C:  CALL   0CA4
....................     lcd_gotoxy(6,1); 
1750:  MOVLW  06
1752:  MOVWF  x90
1754:  MOVLW  01
1756:  MOVWF  x91
1758:  CALL   0C1C
....................     if(OFFSET_Z1<=999) 
175C:  MOVF   52,W
175E:  SUBLW  03
1760:  BNC   177A
1762:  BNZ   176A
1764:  MOVF   51,W
1766:  SUBLW  E7
1768:  BNC   177A
....................       printf(lcd_putc,"%lU" (OFFSET_Z1)); 
176A:  MOVLW  10
176C:  MOVWF  FE9
176E:  MOVFF  52,83
1772:  MOVFF  51,82
1776:  CALL   0D5C
....................     lcd_gotoxy(6,2); 
177A:  MOVLW  06
177C:  MOVWF  x90
177E:  MOVLW  02
1780:  MOVWF  x91
1782:  CALL   0C1C
....................       printf(lcd_putc,"    "); 
1786:  MOVLW  9E
1788:  MOVWF  FF6
178A:  MOVLW  01
178C:  MOVWF  FF7
178E:  CALL   0CA4
....................     lcd_gotoxy(6,2); 
1792:  MOVLW  06
1794:  MOVWF  x90
1796:  MOVLW  02
1798:  MOVWF  x91
179A:  CALL   0C1C
....................     if(OFFSET_Z2<=999) 
179E:  MOVF   54,W
17A0:  SUBLW  03
17A2:  BNC   17BC
17A4:  BNZ   17AC
17A6:  MOVF   53,W
17A8:  SUBLW  E7
17AA:  BNC   17BC
....................        printf(lcd_putc,"%lU" (OFFSET_Z2)); 
17AC:  MOVLW  10
17AE:  MOVWF  FE9
17B0:  MOVFF  54,83
17B4:  MOVFF  53,82
17B8:  CALL   0D5C
....................     lcd_gotoxy(6,3); 
17BC:  MOVLW  06
17BE:  MOVWF  x90
17C0:  MOVLW  03
17C2:  MOVWF  x91
17C4:  CALL   0C1C
....................       printf(lcd_putc,"    "); 
17C8:  MOVLW  A4
17CA:  MOVWF  FF6
17CC:  MOVLW  01
17CE:  MOVWF  FF7
17D0:  CALL   0CA4
....................     lcd_gotoxy(6,3); 
17D4:  MOVLW  06
17D6:  MOVWF  x90
17D8:  MOVLW  03
17DA:  MOVWF  x91
17DC:  CALL   0C1C
....................     if(OFFSET_Z3<=999) 
17E0:  MOVF   56,W
17E2:  SUBLW  03
17E4:  BNC   17FE
17E6:  BNZ   17EE
17E8:  MOVF   55,W
17EA:  SUBLW  E7
17EC:  BNC   17FE
....................        printf(lcd_putc,"%lU" (OFFSET_Z3)); 
17EE:  MOVLW  10
17F0:  MOVWF  FE9
17F2:  MOVFF  56,83
17F6:  MOVFF  55,82
17FA:  CALL   0D5C
....................     lcd_gotoxy(6,4); 
17FE:  MOVLW  06
1800:  MOVWF  x90
1802:  MOVLW  04
1804:  MOVWF  x91
1806:  CALL   0C1C
....................       printf(lcd_putc,"    "); 
180A:  MOVLW  AA
180C:  MOVWF  FF6
180E:  MOVLW  01
1810:  MOVWF  FF7
1812:  CALL   0CA4
....................     lcd_gotoxy(6,4); 
1816:  MOVLW  06
1818:  MOVWF  x90
181A:  MOVLW  04
181C:  MOVWF  x91
181E:  CALL   0C1C
....................     if(OFFSET_Z4<=999) 
1822:  MOVF   58,W
1824:  SUBLW  03
1826:  BNC   1840
1828:  BNZ   1830
182A:  MOVF   57,W
182C:  SUBLW  E7
182E:  BNC   1840
....................       printf(lcd_putc,"%lU" (OFFSET_Z4)); 
1830:  MOVLW  10
1832:  MOVWF  FE9
1834:  MOVFF  58,83
1838:  MOVFF  57,82
183C:  CALL   0D5C
....................   
....................    lcd_gotoxy(17,1); 
1840:  MOVLW  11
1842:  MOVWF  x90
1844:  MOVLW  01
1846:  MOVWF  x91
1848:  CALL   0C1C
....................       printf(lcd_putc,"    "); 
184C:  MOVLW  B0
184E:  MOVWF  FF6
1850:  MOVLW  01
1852:  MOVWF  FF7
1854:  CALL   0CA4
....................     lcd_gotoxy(17,1); 
1858:  MOVLW  11
185A:  MOVWF  x90
185C:  MOVLW  01
185E:  MOVWF  x91
1860:  CALL   0C1C
....................     if(MAX_Z1<=1024) 
1864:  MOVF   5E,W
1866:  SUBLW  04
1868:  BNC   1882
186A:  BNZ   1872
186C:  MOVF   5D,W
186E:  SUBLW  00
1870:  BNC   1882
....................       printf(lcd_putc,"%lU" (MAX_Z1)); 
1872:  MOVLW  10
1874:  MOVWF  FE9
1876:  MOVFF  5E,83
187A:  MOVFF  5D,82
187E:  CALL   0D5C
....................     lcd_gotoxy(17,2); 
1882:  MOVLW  11
1884:  MOVWF  x90
1886:  MOVLW  02
1888:  MOVWF  x91
188A:  CALL   0C1C
....................       printf(lcd_putc,"    "); 
188E:  MOVLW  B6
1890:  MOVWF  FF6
1892:  MOVLW  01
1894:  MOVWF  FF7
1896:  CALL   0CA4
....................     lcd_gotoxy(17,2); 
189A:  MOVLW  11
189C:  MOVWF  x90
189E:  MOVLW  02
18A0:  MOVWF  x91
18A2:  CALL   0C1C
....................     if(MAX_Z2<=1024) 
18A6:  MOVF   x60,W
18A8:  SUBLW  04
18AA:  BNC   18C4
18AC:  BNZ   18B4
18AE:  MOVF   5F,W
18B0:  SUBLW  00
18B2:  BNC   18C4
....................       printf(lcd_putc,"%lU" (MAX_Z2)); 
18B4:  MOVLW  10
18B6:  MOVWF  FE9
18B8:  MOVFF  60,83
18BC:  MOVFF  5F,82
18C0:  CALL   0D5C
....................     lcd_gotoxy(17,3); 
18C4:  MOVLW  11
18C6:  MOVWF  x90
18C8:  MOVLW  03
18CA:  MOVWF  x91
18CC:  CALL   0C1C
....................       printf(lcd_putc,"    "); 
18D0:  MOVLW  BC
18D2:  MOVWF  FF6
18D4:  MOVLW  01
18D6:  MOVWF  FF7
18D8:  CALL   0CA4
....................     lcd_gotoxy(17,3); 
18DC:  MOVLW  11
18DE:  MOVWF  x90
18E0:  MOVLW  03
18E2:  MOVWF  x91
18E4:  CALL   0C1C
....................     if(MAX_Z3<=1024) 
18E8:  MOVF   x62,W
18EA:  SUBLW  04
18EC:  BNC   1906
18EE:  BNZ   18F6
18F0:  MOVF   x61,W
18F2:  SUBLW  00
18F4:  BNC   1906
....................       printf(lcd_putc,"%lU" (MAX_Z3)); 
18F6:  MOVLW  10
18F8:  MOVWF  FE9
18FA:  MOVFF  62,83
18FE:  MOVFF  61,82
1902:  CALL   0D5C
....................     lcd_gotoxy(17,4); 
1906:  MOVLW  11
1908:  MOVWF  x90
190A:  MOVLW  04
190C:  MOVWF  x91
190E:  CALL   0C1C
....................       printf(lcd_putc,"    "); 
1912:  MOVLW  C2
1914:  MOVWF  FF6
1916:  MOVLW  01
1918:  MOVWF  FF7
191A:  CALL   0CA4
....................     lcd_gotoxy(17,4); 
191E:  MOVLW  11
1920:  MOVWF  x90
1922:  MOVLW  04
1924:  MOVWF  x91
1926:  CALL   0C1C
....................     if(MAX_Z4<=1024) 
192A:  MOVF   x64,W
192C:  SUBLW  04
192E:  BNC   1948
1930:  BNZ   1938
1932:  MOVF   x63,W
1934:  SUBLW  00
1936:  BNC   1948
....................        printf(lcd_putc,"%lU" (MAX_Z4)); 
1938:  MOVLW  10
193A:  MOVWF  FE9
193C:  MOVFF  64,83
1940:  MOVFF  63,82
1944:  CALL   0D5C
1948:  RETURN 0
.................... } 
....................  
.................... Void pantalla_3_fija(){ 
....................  
....................    lcd_gotoxy(1,1); 
194A:  MOVLW  01
194C:  MOVWF  x90
194E:  MOVWF  x91
1950:  CALL   0C1C
....................    printf(lcd_putc,"OfMot:"); 
1954:  MOVLW  C8
1956:  MOVWF  FF6
1958:  MOVLW  01
195A:  MOVWF  FF7
195C:  CALL   0CA4
....................    lcd_gotoxy(1,2); 
1960:  MOVLW  01
1962:  MOVWF  x90
1964:  MOVLW  02
1966:  MOVWF  x91
1968:  CALL   0C1C
....................    printf(lcd_putc,"OfAmb:"); 
196C:  MOVLW  D0
196E:  MOVWF  FF6
1970:  MOVLW  01
1972:  MOVWF  FF7
1974:  CALL   0CA4
....................    lcd_gotoxy(11,1); 
1978:  MOVLW  0B
197A:  MOVWF  x90
197C:  MOVLW  01
197E:  MOVWF  x91
1980:  CALL   0C1C
....................     printf(lcd_putc,"MaxM:"); 
1984:  MOVLW  D8
1986:  MOVWF  FF6
1988:  MOVLW  01
198A:  MOVWF  FF7
198C:  CALL   0CA4
....................     lcd_gotoxy(11,2); 
1990:  MOVLW  0B
1992:  MOVWF  x90
1994:  MOVLW  02
1996:  MOVWF  x91
1998:  CALL   0C1C
....................     printf(lcd_putc,"MaxA:"); 
199C:  MOVLW  DE
199E:  MOVWF  FF6
19A0:  MOVLW  01
19A2:  MOVWF  FF7
19A4:  CALL   0CA4
....................     
....................    lcd_gotoxy(7,1); 
19A8:  MOVLW  07
19AA:  MOVWF  x90
19AC:  MOVLW  01
19AE:  MOVWF  x91
19B0:  CALL   0C1C
....................       printf(lcd_putc,"    "); 
19B4:  MOVLW  E4
19B6:  MOVWF  FF6
19B8:  MOVLW  01
19BA:  MOVWF  FF7
19BC:  CALL   0CA4
....................     lcd_gotoxy(7,1); 
19C0:  MOVLW  07
19C2:  MOVWF  x90
19C4:  MOVLW  01
19C6:  MOVWF  x91
19C8:  CALL   0C1C
....................     if(OFFSET_MOT<=100) 
19CC:  MOVF   5C,F
19CE:  BNZ   19E6
19D0:  MOVF   5B,W
19D2:  SUBLW  64
19D4:  BNC   19E6
....................       printf(lcd_putc,"%lU" (OFFSET_MOT)); 
19D6:  MOVLW  10
19D8:  MOVWF  FE9
19DA:  MOVFF  5C,83
19DE:  MOVFF  5B,82
19E2:  CALL   0D5C
....................     lcd_gotoxy(7,2); 
19E6:  MOVLW  07
19E8:  MOVWF  x90
19EA:  MOVLW  02
19EC:  MOVWF  x91
19EE:  CALL   0C1C
....................       printf(lcd_putc,"    "); 
19F2:  MOVLW  EA
19F4:  MOVWF  FF6
19F6:  MOVLW  01
19F8:  MOVWF  FF7
19FA:  CALL   0CA4
....................     lcd_gotoxy(7,2); 
19FE:  MOVLW  07
1A00:  MOVWF  x90
1A02:  MOVLW  02
1A04:  MOVWF  x91
1A06:  CALL   0C1C
....................     if(OFFSET_AMB<=100) 
1A0A:  MOVF   5A,F
1A0C:  BNZ   1A24
1A0E:  MOVF   59,W
1A10:  SUBLW  64
1A12:  BNC   1A24
....................        printf(lcd_putc,"%lU" (OFFSET_AMB)); 
1A14:  MOVLW  10
1A16:  MOVWF  FE9
1A18:  MOVFF  5A,83
1A1C:  MOVFF  59,82
1A20:  CALL   0D5C
....................         lcd_gotoxy(17,1); 
1A24:  MOVLW  11
1A26:  MOVWF  x90
1A28:  MOVLW  01
1A2A:  MOVWF  x91
1A2C:  CALL   0C1C
....................       printf(lcd_putc,"    "); 
1A30:  MOVLW  F0
1A32:  MOVWF  FF6
1A34:  MOVLW  01
1A36:  MOVWF  FF7
1A38:  CALL   0CA4
....................     lcd_gotoxy(17,1); 
1A3C:  MOVLW  11
1A3E:  MOVWF  x90
1A40:  MOVLW  01
1A42:  MOVWF  x91
1A44:  CALL   0C1C
....................     if(MAX_MOT<1024) 
1A48:  MOVF   x68,W
1A4A:  SUBLW  03
1A4C:  BNC   1A5E
....................       printf(lcd_putc,"%lU" (MAX_MOT)); 
1A4E:  MOVLW  10
1A50:  MOVWF  FE9
1A52:  MOVFF  68,83
1A56:  MOVFF  67,82
1A5A:  CALL   0D5C
....................     lcd_gotoxy(17,2); 
1A5E:  MOVLW  11
1A60:  MOVWF  x90
1A62:  MOVLW  02
1A64:  MOVWF  x91
1A66:  CALL   0C1C
....................       printf(lcd_putc,"    "); 
1A6A:  MOVLW  F6
1A6C:  MOVWF  FF6
1A6E:  MOVLW  01
1A70:  MOVWF  FF7
1A72:  CALL   0CA4
....................     lcd_gotoxy(17,2); 
1A76:  MOVLW  11
1A78:  MOVWF  x90
1A7A:  MOVLW  02
1A7C:  MOVWF  x91
1A7E:  CALL   0C1C
....................     if(MAX_AMB<1024) 
1A82:  MOVF   x66,W
1A84:  SUBLW  03
1A86:  BNC   1A98
....................       printf(lcd_putc,"%lU" (MAX_AMB)); 
1A88:  MOVLW  10
1A8A:  MOVWF  FE9
1A8C:  MOVFF  66,83
1A90:  MOVFF  65,82
1A94:  CALL   0D5C
1A98:  RETURN 0
....................    
.................... } 
.................... void Cambiar_pantalla(INT8 key){ 
....................    lcd_putc("\f"); 
*
1BCC:  MOVLW  FC
1BCE:  MOVWF  FF6
1BD0:  MOVLW  01
1BD2:  MOVWF  FF7
1BD4:  CALL   0CA4
....................    if(key==SW_ARRIBA){ 
1BD8:  MOVF   x81,W
1BDA:  SUBLW  03
1BDC:  BNZ   1BEC
....................       if(Pantalla_actual>=3) 
1BDE:  MOVF   x69,W
1BE0:  SUBLW  02
1BE2:  BC    1BE8
....................          Pantalla_actual=0; 
1BE4:  CLRF   x69
1BE6:  BRA    1BEA
....................       else 
....................          Pantalla_actual++; 
1BE8:  INCF   x69,F
....................       //return; 
....................    } 
1BEA:  BRA    1BFE
....................    else if(key==SW_ABAJO){ 
1BEC:  MOVF   x81,W
1BEE:  SUBLW  02
1BF0:  BNZ   1BFE
....................       if(Pantalla_actual==0) 
1BF2:  MOVF   x69,F
1BF4:  BNZ   1BFC
....................          Pantalla_actual=3; 
1BF6:  MOVLW  03
1BF8:  MOVWF  x69
1BFA:  BRA    1BFE
....................       else 
....................          Pantalla_actual--; 
1BFC:  DECF   x69,F
....................       //return; 
....................    } 
....................    CONTADOR_SP=1; 
1BFE:  MOVLW  01
1C00:  MOVWF  x6B
....................    if(Pantalla_actual==0) 
1C02:  MOVF   x69,F
1C04:  BNZ   1C0C
....................       pantalla_0_fija(); 
1C06:  CALL   10B8
1C0A:  BRA    1C2A
....................    else if(Pantalla_actual==1){ 
1C0C:  DECFSZ x69,W
1C0E:  BRA    1C18
....................       CONTADOR_SP=2; 
1C10:  MOVLW  02
1C12:  MOVWF  x6B
....................       pantalla_1_fija(); 
1C14:  RCALL  1448
....................    } 
1C16:  BRA    1C2A
....................    else if(Pantalla_actual==2) 
1C18:  MOVF   x69,W
1C1A:  SUBLW  02
1C1C:  BNZ   1C22
....................       pantalla_2_fija(); 
1C1E:  RCALL  167A
1C20:  BRA    1C2A
....................    else if(Pantalla_actual==3) 
1C22:  MOVF   x69,W
1C24:  SUBLW  03
1C26:  BNZ   1C2A
....................       pantalla_3_fija(); 
1C28:  RCALL  194A
1C2A:  RETURN 0
.................... } 
....................  
.................... #include<Modo_programacion.c> 
.................... void Modo_programacion1(INT16 key){ 
....................    if(Pantalla_actual==2) 
*
229E:  MOVF   x69,W
22A0:  SUBLW  02
22A2:  BNZ   22A8
....................     PANTALLAS_SP(); 
22A4:  RCALL  1C2C
22A6:  BRA    22B4
....................    else if(Pantalla_actual==3) 
22A8:  MOVF   x69,W
22AA:  SUBLW  03
22AC:  BNZ   22B2
....................     PANTALLAS_SP(); 
22AE:  RCALL  1C2C
22B0:  BRA    22B4
....................    else 
....................       PANTALLAS_SP1(); 
22B2:  BRA    2042
....................    if (key==SW_NOKEY) 
22B4:  MOVF   x81,F
22B6:  BNZ   22C4
22B8:  MOVF   x82,F
22BA:  BNZ   22C4
....................       return; 
22BC:  GOTO   28A2
22C0:  GOTO   28A2
....................    else if(key==SW_CENTRO){ 
22C4:  DECFSZ x81,W
22C6:  BRA    2424
22C8:  MOVF   x82,F
22CA:  BTFSS  FD8.2
22CC:  BRA    2424
....................       flag_programacion=0; 
22CE:  CLRF   x6A
....................       lcd_putc("\f"); 
22D0:  MOVLW  FE
22D2:  MOVWF  FF6
22D4:  MOVLW  01
22D6:  MOVWF  FF7
22D8:  CALL   0CA4
....................        lcd_gotoxy(5,2); 
22DC:  MOVLW  05
22DE:  MOVWF  x90
22E0:  MOVLW  02
22E2:  MOVWF  x91
22E4:  CALL   0C1C
....................        Guardar_EEPROM(SP_Z1,DIR_SPZ1); 
22E8:  MOVFF  46,84
22EC:  MOVFF  45,83
22F0:  CLRF   x86
22F2:  MOVLW  06
22F4:  MOVWF  x85
22F6:  RCALL  219C
....................        Guardar_EEPROM(SP_Z2,DIR_SPZ2); 
22F8:  MOVFF  48,84
22FC:  MOVFF  47,83
2300:  CLRF   x86
2302:  MOVLW  04
2304:  MOVWF  x85
2306:  RCALL  219C
....................        Guardar_EEPROM(SP_Z3,DIR_SPZ3); 
2308:  MOVFF  4A,84
230C:  MOVFF  49,83
2310:  CLRF   x86
2312:  MOVLW  02
2314:  MOVWF  x85
2316:  RCALL  219C
....................        Guardar_EEPROM(SP_Z4,DIR_SPZ4); 
2318:  MOVFF  4C,84
231C:  MOVFF  4B,83
2320:  CLRF   x86
2322:  CLRF   x85
2324:  RCALL  219C
....................        Guardar_EEPROM(OFFSET_Z1,DIR_OFF_Z1); 
2326:  MOVFF  52,84
232A:  MOVFF  51,83
232E:  CLRF   x86
2330:  MOVLW  14
2332:  MOVWF  x85
2334:  RCALL  219C
....................        Guardar_EEPROM(OFFSET_Z2,DIR_OFF_Z2); 
2336:  MOVFF  54,84
233A:  MOVFF  53,83
233E:  CLRF   x86
2340:  MOVLW  16
2342:  MOVWF  x85
2344:  RCALL  219C
....................        Guardar_EEPROM( OFFSET_Z3,DIR_OFF_Z3); 
2346:  MOVFF  56,84
234A:  MOVFF  55,83
234E:  CLRF   x86
2350:  MOVLW  18
2352:  MOVWF  x85
2354:  RCALL  219C
....................        Guardar_EEPROM( OFFSET_Z4,DIR_OFF_Z4); 
2356:  MOVFF  58,84
235A:  MOVFF  57,83
235E:  CLRF   x86
2360:  MOVLW  1A
2362:  MOVWF  x85
2364:  RCALL  219C
....................        Guardar_EEPROM( OFFSET_MOT,DIR_OFF_MOT); 
2366:  MOVFF  5C,84
236A:  MOVFF  5B,83
236E:  CLRF   x86
2370:  MOVLW  20
2372:  MOVWF  x85
2374:  RCALL  219C
....................        Guardar_EEPROM( OFFSET_AMB,DIR_OFF_AMB); 
2376:  MOVFF  5A,84
237A:  MOVFF  59,83
237E:  CLRF   x86
2380:  MOVLW  22
2382:  MOVWF  x85
2384:  RCALL  219C
....................        Guardar_EEPROM(MAX_Z1,DIR_MAX_Z1); 
2386:  MOVFF  5E,84
238A:  MOVFF  5D,83
238E:  CLRF   x86
2390:  MOVLW  0C
2392:  MOVWF  x85
2394:  RCALL  219C
....................        Guardar_EEPROM(MAX_Z2,DIR_MAX_Z2); 
2396:  MOVFF  60,84
239A:  MOVFF  5F,83
239E:  CLRF   x86
23A0:  MOVLW  0E
23A2:  MOVWF  x85
23A4:  RCALL  219C
....................        Guardar_EEPROM(MAX_Z3,DIR_MAX_Z3); 
23A6:  MOVFF  62,84
23AA:  MOVFF  61,83
23AE:  CLRF   x86
23B0:  MOVLW  10
23B2:  MOVWF  x85
23B4:  RCALL  219C
....................        Guardar_EEPROM(MAX_Z4,DIR_MAX_Z4); 
23B6:  MOVFF  64,84
23BA:  MOVFF  63,83
23BE:  CLRF   x86
23C0:  MOVLW  12
23C2:  MOVWF  x85
23C4:  RCALL  219C
....................        Guardar_EEPROM(MAX_MOT,DIR_MAX_MOT); 
23C6:  MOVFF  68,84
23CA:  MOVFF  67,83
23CE:  CLRF   x86
23D0:  MOVLW  1C
23D2:  MOVWF  x85
23D4:  RCALL  219C
....................        Guardar_EEPROM(MAX_AMB,DIR_MAX_AMB); 
23D6:  MOVFF  66,84
23DA:  MOVFF  65,83
23DE:  CLRF   x86
23E0:  MOVLW  1E
23E2:  MOVWF  x85
23E4:  RCALL  219C
....................        Guardar_EEPROM(SP_I_MOT,DIR_SP_I_MOT); 
23E6:  MOVFF  4E,84
23EA:  MOVFF  4D,83
23EE:  CLRF   x86
23F0:  MOVLW  08
23F2:  MOVWF  x85
23F4:  RCALL  219C
....................        Guardar_EEPROM(SP_T_MOT,DIR_SP_T_MOT); 
23F6:  MOVFF  50,84
23FA:  MOVFF  4F,83
23FE:  CLRF   x86
2400:  MOVLW  0A
2402:  MOVWF  x85
2404:  RCALL  219C
....................        printf(lcd_putc,"Datos Guardados"); 
2406:  MOVLW  00
2408:  MOVWF  FF6
240A:  MOVLW  02
240C:  MOVWF  FF7
240E:  CALL   0CA4
....................              Beep_corto(); 
2412:  BRA    226A
....................              lcd_putc("\f"); 
2414:  MOVLW  10
2416:  MOVWF  FF6
2418:  MOVLW  02
241A:  MOVWF  FF7
241C:  CALL   0CA4
....................       return; 
2420:  BRA    28A2
....................    } 
2422:  BRA    28A2
....................    else if(key==SW_ABAJO){ 
2424:  MOVF   x81,W
2426:  SUBLW  02
2428:  BNZ   2484
242A:  MOVF   x82,F
242C:  BNZ   2484
....................       if(Pantalla_actual==1){ 
242E:  DECFSZ x69,W
2430:  BRA    2442
....................          if(CONTADOR_SP==2) 
2432:  MOVF   x6B,W
2434:  SUBLW  02
2436:  BNZ   243E
....................             CONTADOR_SP=3; 
2438:  MOVLW  03
243A:  MOVWF  x6B
243C:  BRA    2440
....................          else 
....................             CONTADOR_SP--; 
243E:  DECF   x6B,F
....................       } 
2440:  BRA    2482
....................       else if(Pantalla_actual==2){ 
2442:  MOVF   x69,W
2444:  SUBLW  02
2446:  BNZ   2456
....................          if(CONTADOR_SP==1) 
2448:  DECFSZ x6B,W
244A:  BRA    2452
....................             CONTADOR_SP=8; 
244C:  MOVLW  08
244E:  MOVWF  x6B
2450:  BRA    2454
....................          else 
....................             CONTADOR_SP--; 
2452:  DECF   x6B,F
....................        
....................       } 
2454:  BRA    2482
....................       else if(Pantalla_actual==3){ 
2456:  MOVF   x69,W
2458:  SUBLW  03
245A:  BNZ   2476
....................          if(CONTADOR_SP==1) 
245C:  DECFSZ x6B,W
245E:  BRA    2466
....................             CONTADOR_SP=6; 
2460:  MOVLW  06
2462:  MOVWF  x6B
2464:  BRA    2474
....................          ELSE IF(CONTADOR_SP==5) 
2466:  MOVF   x6B,W
2468:  SUBLW  05
246A:  BNZ   2472
....................             CONTADOR_SP=2; 
246C:  MOVLW  02
246E:  MOVWF  x6B
2470:  BRA    2474
....................          ELSE  
....................             CONTADOR_SP--; 
2472:  DECF   x6B,F
....................       } 
2474:  BRA    2482
....................       else{ 
....................          if(CONTADOR_SP==1) 
2476:  DECFSZ x6B,W
2478:  BRA    2480
....................             CONTADOR_SP=4; 
247A:  MOVLW  04
247C:  MOVWF  x6B
247E:  BRA    2482
....................          else 
....................             CONTADOR_SP--; 
2480:  DECF   x6B,F
....................       } 
....................    } 
2482:  BRA    28A2
....................    else if(key==SW_ARRIBA){ 
2484:  MOVF   x81,W
2486:  SUBLW  03
2488:  BNZ   24EA
248A:  MOVF   x82,F
248C:  BNZ   24EA
....................       if(Pantalla_actual==1){ 
248E:  DECFSZ x69,W
2490:  BRA    24A2
....................          if(CONTADOR_SP==3) 
2492:  MOVF   x6B,W
2494:  SUBLW  03
2496:  BNZ   249E
....................             CONTADOR_SP=2; 
2498:  MOVLW  02
249A:  MOVWF  x6B
249C:  BRA    24A0
....................          else 
....................             CONTADOR_SP++; 
249E:  INCF   x6B,F
....................       } 
24A0:  BRA    24E8
....................       else if(Pantalla_actual==2){ 
24A2:  MOVF   x69,W
24A4:  SUBLW  02
24A6:  BNZ   24B8
....................          if(CONTADOR_SP==8) 
24A8:  MOVF   x6B,W
24AA:  SUBLW  08
24AC:  BNZ   24B4
....................             CONTADOR_SP=1; 
24AE:  MOVLW  01
24B0:  MOVWF  x6B
24B2:  BRA    24B6
....................          else 
....................             CONTADOR_SP++; 
24B4:  INCF   x6B,F
....................       } 
24B6:  BRA    24E8
....................       else if(Pantalla_actual==3){ 
24B8:  MOVF   x69,W
24BA:  SUBLW  03
24BC:  BNZ   24DA
....................          if(CONTADOR_SP==2) 
24BE:  MOVF   x6B,W
24C0:  SUBLW  02
24C2:  BNZ   24CA
....................             CONTADOR_SP=5; 
24C4:  MOVLW  05
24C6:  MOVWF  x6B
24C8:  BRA    24D8
....................          ELSE IF(CONTADOR_SP==6) 
24CA:  MOVF   x6B,W
24CC:  SUBLW  06
24CE:  BNZ   24D6
....................             CONTADOR_SP=1; 
24D0:  MOVLW  01
24D2:  MOVWF  x6B
24D4:  BRA    24D8
....................          ELSE  
....................             CONTADOR_SP++; 
24D6:  INCF   x6B,F
....................       } 
24D8:  BRA    24E8
....................       else{ 
....................          if(CONTADOR_SP==4) 
24DA:  MOVF   x6B,W
24DC:  SUBLW  04
24DE:  BNZ   24E6
....................             CONTADOR_SP=1; 
24E0:  MOVLW  01
24E2:  MOVWF  x6B
24E4:  BRA    24E8
....................          else 
....................             CONTADOR_SP++; 
24E6:  INCF   x6B,F
....................       } 
....................    } 
24E8:  BRA    28A2
....................    else if(key==SW_DERECHA){ 
24EA:  MOVF   x81,W
24EC:  SUBLW  05
24EE:  BTFSS  FD8.2
24F0:  BRA    26B6
24F2:  MOVF   x82,F
24F4:  BTFSS  FD8.2
24F6:  BRA    26B6
....................       if(Pantalla_actual==0){ 
24F8:  MOVF   x69,F
24FA:  BNZ   2582
....................          if(CONTADOR_SP==1){ 
24FC:  DECFSZ x6B,W
24FE:  BRA    251C
....................             if(SP_Z1>=300) 
2500:  MOVF   46,W
2502:  SUBLW  00
2504:  BC    2514
2506:  XORLW  FF
2508:  BNZ   2510
250A:  MOVF   45,W
250C:  SUBLW  2B
250E:  BC    2514
....................                SP_Z1=0; 
2510:  CLRF   46
2512:  CLRF   45
....................             SP_Z1++; 
2514:  INCF   45,F
2516:  BTFSC  FD8.2
2518:  INCF   46,F
....................          } 
251A:  BRA    2580
....................          else if(CONTADOR_SP==2){ 
251C:  MOVF   x6B,W
251E:  SUBLW  02
2520:  BNZ   253E
....................             if(SP_Z2>=300) 
2522:  MOVF   48,W
2524:  SUBLW  00
2526:  BC    2536
2528:  XORLW  FF
252A:  BNZ   2532
252C:  MOVF   47,W
252E:  SUBLW  2B
2530:  BC    2536
....................                SP_Z2=0; 
2532:  CLRF   48
2534:  CLRF   47
....................             SP_Z2++; 
2536:  INCF   47,F
2538:  BTFSC  FD8.2
253A:  INCF   48,F
....................          } 
253C:  BRA    2580
....................          else if(CONTADOR_SP==3){ 
253E:  MOVF   x6B,W
2540:  SUBLW  03
2542:  BNZ   2560
....................             if(SP_Z3>=300) 
2544:  MOVF   4A,W
2546:  SUBLW  00
2548:  BC    2558
254A:  XORLW  FF
254C:  BNZ   2554
254E:  MOVF   49,W
2550:  SUBLW  2B
2552:  BC    2558
....................                SP_Z3=0; 
2554:  CLRF   4A
2556:  CLRF   49
....................             SP_Z3++; 
2558:  INCF   49,F
255A:  BTFSC  FD8.2
255C:  INCF   4A,F
....................          } 
255E:  BRA    2580
....................          else if(CONTADOR_SP==4){ 
2560:  MOVF   x6B,W
2562:  SUBLW  04
2564:  BNZ   2580
....................             if(SP_Z4>=300) 
2566:  MOVF   4C,W
2568:  SUBLW  00
256A:  BC    257A
256C:  XORLW  FF
256E:  BNZ   2576
2570:  MOVF   4B,W
2572:  SUBLW  2B
2574:  BC    257A
....................                SP_Z4=0; 
2576:  CLRF   4C
2578:  CLRF   4B
....................             SP_Z4++; 
257A:  INCF   4B,F
257C:  BTFSC  FD8.2
257E:  INCF   4C,F
....................          } 
....................           
....................       } 
2580:  BRA    26B4
....................       else if(Pantalla_actual==1){ 
2582:  DECFSZ x69,W
2584:  BRA    25BE
....................          if(CONTADOR_SP==3){ 
2586:  MOVF   x6B,W
2588:  SUBLW  03
258A:  BNZ   25A2
....................             if(SP_I_MOT>=100) 
258C:  MOVF   4E,F
258E:  BNZ   2596
2590:  MOVF   4D,W
2592:  SUBLW  63
2594:  BC    259A
....................                SP_I_MOT=0; 
2596:  CLRF   4E
2598:  CLRF   4D
....................             SP_I_MOT++; 
259A:  INCF   4D,F
259C:  BTFSC  FD8.2
259E:  INCF   4E,F
....................          } 
25A0:  BRA    25BC
....................          else if(CONTADOR_SP==2){ 
25A2:  MOVF   x6B,W
25A4:  SUBLW  02
25A6:  BNZ   25BC
....................             if(SP_T_MOT>=100) 
25A8:  MOVF   50,F
25AA:  BNZ   25B2
25AC:  MOVF   4F,W
25AE:  SUBLW  63
25B0:  BC    25B6
....................                SP_T_MOT=0; 
25B2:  CLRF   50
25B4:  CLRF   4F
....................             SP_T_MOT++; 
25B6:  INCF   4F,F
25B8:  BTFSC  FD8.2
25BA:  INCF   50,F
....................          } 
....................       } 
25BC:  BRA    26B4
....................       else if(Pantalla_actual==2){  
25BE:  MOVF   x69,W
25C0:  SUBLW  02
25C2:  BNZ   2662
....................          if(CONTADOR_SP==1) 
25C4:  DECFSZ x6B,W
25C6:  BRA    25D2
....................             OFFSET_Z1 = ADC_TERMOCUPLA_Z1; 
25C8:  MOVFF  18,52
25CC:  MOVFF  17,51
25D0:  BRA    2660
....................          else if(CONTADOR_SP==2) 
25D2:  MOVF   x6B,W
25D4:  SUBLW  02
25D6:  BNZ   25E2
....................             OFFSET_Z2 = ADC_TERMOCUPLA_Z2; 
25D8:  MOVFF  1C,54
25DC:  MOVFF  1B,53
25E0:  BRA    2660
....................          else if(CONTADOR_SP==3) 
25E2:  MOVF   x6B,W
25E4:  SUBLW  03
25E6:  BNZ   25F2
....................             OFFSET_Z3 = ADC_TERMOCUPLA_Z3; 
25E8:  MOVFF  20,56
25EC:  MOVFF  1F,55
25F0:  BRA    2660
....................          else if(CONTADOR_SP==4) 
25F2:  MOVF   x6B,W
25F4:  SUBLW  04
25F6:  BNZ   2602
....................             OFFSET_Z4 = ADC_TERMOCUPLA_Z4; 
25F8:  MOVFF  24,58
25FC:  MOVFF  23,57
2600:  BRA    2660
....................          else if(CONTADOR_SP==5){ 
2602:  MOVF   x6B,W
2604:  SUBLW  05
2606:  BNZ   261A
....................             if(MAX_Z1>=1024) 
2608:  MOVF   5E,W
260A:  SUBLW  03
260C:  BC    2612
....................                MAX_Z1=0; 
260E:  CLRF   5E
2610:  CLRF   5D
....................             MAX_Z1++; 
2612:  INCF   5D,F
2614:  BTFSC  FD8.2
2616:  INCF   5E,F
....................          } 
2618:  BRA    2660
....................          else if(CONTADOR_SP==6){ 
261A:  MOVF   x6B,W
261C:  SUBLW  06
261E:  BNZ   2632
....................             if(MAX_Z2>=1024) 
2620:  MOVF   x60,W
2622:  SUBLW  03
2624:  BC    262A
....................                MAX_Z2=0; 
2626:  CLRF   x60
2628:  CLRF   5F
....................             MAX_Z2++; 
262A:  INCF   5F,F
262C:  BTFSC  FD8.2
262E:  INCF   x60,F
....................          } 
2630:  BRA    2660
....................          else if(CONTADOR_SP==7){ 
2632:  MOVF   x6B,W
2634:  SUBLW  07
2636:  BNZ   264A
....................             if(MAX_Z3>=1024) 
2638:  MOVF   x62,W
263A:  SUBLW  03
263C:  BC    2642
....................                MAX_Z3=0; 
263E:  CLRF   x62
2640:  CLRF   x61
....................             MAX_Z3++; 
2642:  INCF   x61,F
2644:  BTFSC  FD8.2
2646:  INCF   x62,F
....................          } 
2648:  BRA    2660
....................          else if(CONTADOR_SP==8){ 
264A:  MOVF   x6B,W
264C:  SUBLW  08
264E:  BNZ   2660
....................             if(MAX_Z4>=1024) 
2650:  MOVF   x64,W
2652:  SUBLW  03
2654:  BC    265A
....................                MAX_Z4=0; 
2656:  CLRF   x64
2658:  CLRF   x63
....................             MAX_Z4++; 
265A:  INCF   x63,F
265C:  BTFSC  FD8.2
265E:  INCF   x64,F
....................          } 
....................       } 
2660:  BRA    26B4
....................       ELSE IF(Pantalla_actual==3){ 
2662:  MOVF   x69,W
2664:  SUBLW  03
2666:  BNZ   26B4
....................          if(CONTADOR_SP==1) 
2668:  DECFSZ x6B,W
266A:  BRA    2676
....................             OFFSET_MOT = ADC_TEMPERATURA_MOTOR; 
266C:  MOVFF  2C,5C
2670:  MOVFF  2B,5B
2674:  BRA    26B4
....................          else if(CONTADOR_SP==2) 
2676:  MOVF   x6B,W
2678:  SUBLW  02
267A:  BNZ   2686
....................             OFFSET_AMB = ADC_TEMPERATURA_AMBIENTE; 
267C:  MOVFF  28,5A
2680:  MOVFF  27,59
2684:  BRA    26B4
....................          else if(CONTADOR_SP==5){ 
2686:  MOVF   x6B,W
2688:  SUBLW  05
268A:  BNZ   269E
....................             if(MAX_MOT>=1024) 
268C:  MOVF   x68,W
268E:  SUBLW  03
2690:  BC    2696
....................                MAX_MOT=0; 
2692:  CLRF   x68
2694:  CLRF   x67
....................             MAX_MOT++; 
2696:  INCF   x67,F
2698:  BTFSC  FD8.2
269A:  INCF   x68,F
....................          } 
269C:  BRA    26B4
....................          else if(CONTADOR_SP==6){ 
269E:  MOVF   x6B,W
26A0:  SUBLW  06
26A2:  BNZ   26B4
....................             if(MAX_AMB>=1024) 
26A4:  MOVF   x66,W
26A6:  SUBLW  03
26A8:  BC    26AE
....................                MAX_AMB=0; 
26AA:  CLRF   x66
26AC:  CLRF   x65
....................             MAX_AMB++; 
26AE:  INCF   x65,F
26B0:  BTFSC  FD8.2
26B2:  INCF   x66,F
....................          } 
....................       }       
....................    } 
26B4:  BRA    28A2
....................    else if(key==SW_IZQUIERDA){ 
26B6:  MOVF   x81,W
26B8:  SUBLW  04
26BA:  BTFSS  FD8.2
26BC:  BRA    28A2
26BE:  MOVF   x82,F
26C0:  BTFSS  FD8.2
26C2:  BRA    28A2
....................          if(Pantalla_actual==0){ 
26C4:  MOVF   x69,F
26C6:  BNZ   2746
....................          if(CONTADOR_SP==1){ 
26C8:  DECFSZ x6B,W
26CA:  BRA    26E6
....................             if(SP_Z1<=0) 
26CC:  MOVF   45,F
26CE:  BNZ   26DC
26D0:  MOVF   46,F
26D2:  BNZ   26DC
....................                SP_Z1=300; 
26D4:  MOVLW  01
26D6:  MOVWF  46
26D8:  MOVLW  2C
26DA:  MOVWF  45
....................             SP_Z1--; 
26DC:  MOVF   45,W
26DE:  BTFSC  FD8.2
26E0:  DECF   46,F
26E2:  DECF   45,F
....................          } 
26E4:  BRA    2744
....................          else if(CONTADOR_SP==2){ 
26E6:  MOVF   x6B,W
26E8:  SUBLW  02
26EA:  BNZ   2706
....................             if(SP_Z2<=0) 
26EC:  MOVF   47,F
26EE:  BNZ   26FC
26F0:  MOVF   48,F
26F2:  BNZ   26FC
....................                SP_Z2=300; 
26F4:  MOVLW  01
26F6:  MOVWF  48
26F8:  MOVLW  2C
26FA:  MOVWF  47
....................             SP_Z2--; 
26FC:  MOVF   47,W
26FE:  BTFSC  FD8.2
2700:  DECF   48,F
2702:  DECF   47,F
....................          } 
2704:  BRA    2744
....................          else if(CONTADOR_SP==3){ 
2706:  MOVF   x6B,W
2708:  SUBLW  03
270A:  BNZ   2726
....................             if(SP_Z3<=0) 
270C:  MOVF   49,F
270E:  BNZ   271C
2710:  MOVF   4A,F
2712:  BNZ   271C
....................                SP_Z3=300; 
2714:  MOVLW  01
2716:  MOVWF  4A
2718:  MOVLW  2C
271A:  MOVWF  49
....................             SP_Z3--; 
271C:  MOVF   49,W
271E:  BTFSC  FD8.2
2720:  DECF   4A,F
2722:  DECF   49,F
....................          } 
2724:  BRA    2744
....................          else if(CONTADOR_SP==4){ 
2726:  MOVF   x6B,W
2728:  SUBLW  04
272A:  BNZ   2744
....................             if(SP_Z4<=0) 
272C:  MOVF   4B,F
272E:  BNZ   273C
2730:  MOVF   4C,F
2732:  BNZ   273C
....................                SP_Z4=300; 
2734:  MOVLW  01
2736:  MOVWF  4C
2738:  MOVLW  2C
273A:  MOVWF  4B
....................             SP_Z4--; 
273C:  MOVF   4B,W
273E:  BTFSC  FD8.2
2740:  DECF   4C,F
2742:  DECF   4B,F
....................          } 
....................           
....................       } 
2744:  BRA    28A2
....................       else if(Pantalla_actual==1){ 
2746:  DECFSZ x69,W
2748:  BRA    2786
....................          if(CONTADOR_SP==3){ 
274A:  MOVF   x6B,W
274C:  SUBLW  03
274E:  BNZ   2768
....................             if(SP_I_MOT<=0) 
2750:  MOVF   4D,F
2752:  BNZ   275E
2754:  MOVF   4E,F
2756:  BNZ   275E
....................                SP_I_MOT=100; 
2758:  CLRF   4E
275A:  MOVLW  64
275C:  MOVWF  4D
....................             SP_I_MOT--; 
275E:  MOVF   4D,W
2760:  BTFSC  FD8.2
2762:  DECF   4E,F
2764:  DECF   4D,F
....................          } 
2766:  BRA    2784
....................          else if(CONTADOR_SP==2){ 
2768:  MOVF   x6B,W
276A:  SUBLW  02
276C:  BNZ   2784
....................             if(SP_T_MOT<=0) 
276E:  MOVF   4F,F
2770:  BNZ   277C
2772:  MOVF   50,F
2774:  BNZ   277C
....................                SP_T_MOT=100; 
2776:  CLRF   50
2778:  MOVLW  64
277A:  MOVWF  4F
....................             SP_T_MOT--; 
277C:  MOVF   4F,W
277E:  BTFSC  FD8.2
2780:  DECF   50,F
2782:  DECF   4F,F
....................          } 
....................       } 
2784:  BRA    28A2
....................       else if(Pantalla_actual==2){ 
2786:  MOVF   x69,W
2788:  SUBLW  02
278A:  BTFSS  FD8.2
278C:  BRA    2844
....................          if(CONTADOR_SP==1) 
278E:  DECFSZ x6B,W
2790:  BRA    279C
....................             OFFSET_Z1 = ADC_TERMOCUPLA_Z1; 
2792:  MOVFF  18,52
2796:  MOVFF  17,51
279A:  BRA    2842
....................          else if(CONTADOR_SP==2) 
279C:  MOVF   x6B,W
279E:  SUBLW  02
27A0:  BNZ   27AC
....................             OFFSET_Z2 = ADC_TERMOCUPLA_Z2; 
27A2:  MOVFF  1C,54
27A6:  MOVFF  1B,53
27AA:  BRA    2842
....................          else if(CONTADOR_SP==3) 
27AC:  MOVF   x6B,W
27AE:  SUBLW  03
27B0:  BNZ   27BC
....................             OFFSET_Z3 = ADC_TERMOCUPLA_Z3; 
27B2:  MOVFF  20,56
27B6:  MOVFF  1F,55
27BA:  BRA    2842
....................          else if(CONTADOR_SP==4) 
27BC:  MOVF   x6B,W
27BE:  SUBLW  04
27C0:  BNZ   27CC
....................             OFFSET_Z4 = ADC_TERMOCUPLA_Z4; 
27C2:  MOVFF  24,58
27C6:  MOVFF  23,57
27CA:  BRA    2842
....................          else if(CONTADOR_SP==5){ 
27CC:  MOVF   x6B,W
27CE:  SUBLW  05
27D0:  BNZ   27EA
....................             if(MAX_Z1<=0) 
27D2:  MOVF   5D,F
27D4:  BNZ   27E0
27D6:  MOVF   5E,F
27D8:  BNZ   27E0
....................                MAX_Z1=1024; 
27DA:  MOVLW  04
27DC:  MOVWF  5E
27DE:  CLRF   5D
....................             MAX_Z1--; 
27E0:  MOVF   5D,W
27E2:  BTFSC  FD8.2
27E4:  DECF   5E,F
27E6:  DECF   5D,F
....................          } 
27E8:  BRA    2842
....................          else if(CONTADOR_SP==6){ 
27EA:  MOVF   x6B,W
27EC:  SUBLW  06
27EE:  BNZ   2808
....................             if(MAX_Z2<=0) 
27F0:  MOVF   5F,F
27F2:  BNZ   27FE
27F4:  MOVF   x60,F
27F6:  BNZ   27FE
....................                MAX_Z2=1024; 
27F8:  MOVLW  04
27FA:  MOVWF  x60
27FC:  CLRF   5F
....................             MAX_Z2--; 
27FE:  MOVF   5F,W
2800:  BTFSC  FD8.2
2802:  DECF   x60,F
2804:  DECF   5F,F
....................          } 
2806:  BRA    2842
....................          else if(CONTADOR_SP==7){ 
2808:  MOVF   x6B,W
280A:  SUBLW  07
280C:  BNZ   2826
....................             if(MAX_Z3<=0) 
280E:  MOVF   x61,F
2810:  BNZ   281C
2812:  MOVF   x62,F
2814:  BNZ   281C
....................                MAX_Z3=1024; 
2816:  MOVLW  04
2818:  MOVWF  x62
281A:  CLRF   x61
....................             MAX_Z3--; 
281C:  MOVF   x61,W
281E:  BTFSC  FD8.2
2820:  DECF   x62,F
2822:  DECF   x61,F
....................          } 
2824:  BRA    2842
....................          else if(CONTADOR_SP==8){ 
2826:  MOVF   x6B,W
2828:  SUBLW  08
282A:  BNZ   2842
....................             if(MAX_Z4<=0) 
282C:  MOVF   x63,F
282E:  BNZ   283A
2830:  MOVF   x64,F
2832:  BNZ   283A
....................                MAX_Z4=1024; 
2834:  MOVLW  04
2836:  MOVWF  x64
2838:  CLRF   x63
....................             MAX_Z4--; 
283A:  MOVF   x63,W
283C:  BTFSC  FD8.2
283E:  DECF   x64,F
2840:  DECF   x63,F
....................          } 
....................       } 
2842:  BRA    28A2
....................       ELSE IF(Pantalla_actual==3){ 
2844:  MOVF   x69,W
2846:  SUBLW  03
2848:  BNZ   28A2
....................          if(CONTADOR_SP==1) 
284A:  DECFSZ x6B,W
284C:  BRA    2858
....................             OFFSET_MOT = ADC_TEMPERATURA_MOTOR; 
284E:  MOVFF  2C,5C
2852:  MOVFF  2B,5B
2856:  BRA    28A2
....................          else if(CONTADOR_SP==2) 
2858:  MOVF   x6B,W
285A:  SUBLW  02
285C:  BNZ   2868
....................             OFFSET_AMB = ADC_TEMPERATURA_AMBIENTE; 
285E:  MOVFF  28,5A
2862:  MOVFF  27,59
2866:  BRA    28A2
....................          else if(CONTADOR_SP==5){ 
2868:  MOVF   x6B,W
286A:  SUBLW  05
286C:  BNZ   2886
....................             if(MAX_MOT<=0) 
286E:  MOVF   x67,F
2870:  BNZ   287C
2872:  MOVF   x68,F
2874:  BNZ   287C
....................                MAX_MOT=1024; 
2876:  MOVLW  04
2878:  MOVWF  x68
287A:  CLRF   x67
....................             MAX_MOT--; 
287C:  MOVF   x67,W
287E:  BTFSC  FD8.2
2880:  DECF   x68,F
2882:  DECF   x67,F
....................          } 
2884:  BRA    28A2
....................          else if(CONTADOR_SP==6){ 
2886:  MOVF   x6B,W
2888:  SUBLW  06
288A:  BNZ   28A2
....................             if(MAX_AMB<=0) 
288C:  MOVF   x65,F
288E:  BNZ   289A
2890:  MOVF   x66,F
2892:  BNZ   289A
....................                MAX_AMB=1024; 
2894:  MOVLW  04
2896:  MOVWF  x66
2898:  CLRF   x65
....................             MAX_AMB--; 
289A:  MOVF   x65,W
289C:  BTFSC  FD8.2
289E:  DECF   x66,F
28A0:  DECF   x65,F
....................          } 
....................       } 
....................    } 
28A2:  GOTO   2BB4 (RETURN)
....................     
.................... } 
....................  
....................  
....................  
.................... int8 CS; 
.................... #include "MAX6675.c" 
.................... #include "MAX6675.h" 
.................... //#define CS_pin             pin_E2 
.................... #define SCK_pin            pin_E0 
.................... #define SO_pin             input(pin_A1) 
....................  
.................... #define T_min              0 
.................... #define T_max              1024 
....................  
.................... #define count_max          4096 
....................  
.................... #define no_of_pulses       16 
....................  
.................... #define deg_C              0 
.................... #define deg_F              1 
.................... #define tmp_K              2 
....................  
.................... #define open_contact       0x04 
.................... #define close_contact      0x00 
....................  
.................... #define scalar_deg_C       0.25 
.................... #define scalar_deg_F_1     1.8 
.................... #define scalar_deg_F_2     32.0 
.................... #define scalar_tmp_k       273.0 
....................  
.................... #define no_of_samples      16 
....................  
....................  
.................... void MAX6675_init(); 
.................... unsigned char MAX6657_get_ADC(unsigned long *ADC_data); 
.................... float MAX6675_get_T(unsigned long ADC_value, unsigned char T_unit); 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... void MAX6675_init() 
.................... { 
....................    set_tris_C(0x04); 
*
0A26:  MOVLW  04
0A28:  MOVWF  F94
....................     
....................    //output_high(CS_pin); 
....................    IF (CS == 0){ 
0A2A:  MOVF   x74,F
0A2C:  BNZ   0A32
....................    output_HIGH(pin_A3); 
0A2E:  BCF    F92.3
0A30:  BSF    F89.3
....................    } 
....................       IF (CS == 1){ 
0A32:  DECFSZ x74,W
0A34:  BRA    0A3A
....................    output_HIGH(pin_A5); 
0A36:  BCF    F92.5
0A38:  BSF    F89.5
....................    } 
....................       IF (CS == 2){ 
0A3A:  MOVF   x74,W
0A3C:  SUBLW  02
0A3E:  BNZ   0A44
....................    output_HIGH(pin_E1); 
0A40:  BCF    F96.1
0A42:  BSF    F8D.1
....................    } 
....................       IF (CS == 3){ 
0A44:  MOVF   x74,W
0A46:  SUBLW  03
0A48:  BNZ   0A4E
....................    output_HIGH(pin_E2); 
0A4A:  BCF    F96.2
0A4C:  BSF    F8D.2
....................    } 
....................     
....................     
....................    output_high(SCK_pin); 
0A4E:  BCF    F96.0
0A50:  BSF    F8D.0
0A52:  GOTO   0AA2 (RETURN)
.................... } 
....................  
....................  
.................... unsigned char MAX6657_get_ADC(unsigned long *ADC_data) 
*
0212:  CLRF   xA1
0214:  MOVLW  10
0216:  MOVWF  xA2
0218:  CLRF   xA4
021A:  CLRF   xA3
021C:  CLRF   xA8
021E:  CLRF   xA7
0220:  CLRF   xA6
0222:  CLRF   xA5
.................... { 
....................    unsigned char clk_pulses = 0x00; 
....................    unsigned char samples = no_of_samples; 
....................    unsigned long temp_data = 0x0000; 
....................    unsigned long long avg_value = 0x00000000; 
....................     
....................     
....................    while(samples > 0) 
0224:  MOVF   xA2,F
0226:  BZ    02B8
....................    { 
....................          clk_pulses = no_of_pulses; 
0228:  MOVLW  10
022A:  MOVWF  xA1
....................          temp_data = 0x0000; 
022C:  CLRF   xA4
022E:  CLRF   xA3
....................           
....................          //output_low(CS_pin); 
....................             IF (CS == 0){ 
0230:  MOVF   x74,F
0232:  BNZ   0238
....................    output_low(pin_A3); 
0234:  BCF    F92.3
0236:  BCF    F89.3
....................    } 
....................       IF (CS == 1){ 
0238:  DECFSZ x74,W
023A:  BRA    0240
....................    output_low(pin_A5); 
023C:  BCF    F92.5
023E:  BCF    F89.5
....................    } 
....................       IF (CS == 2){ 
0240:  MOVF   x74,W
0242:  SUBLW  02
0244:  BNZ   024A
....................    output_low(pin_E1); 
0246:  BCF    F96.1
0248:  BCF    F8D.1
....................    } 
....................       IF (CS == 3){ 
024A:  MOVF   x74,W
024C:  SUBLW  03
024E:  BNZ   0254
....................    output_low(pin_E2); 
0250:  BCF    F96.2
0252:  BCF    F8D.2
....................    } 
....................           
....................          while(clk_pulses > 0) 
0254:  MOVF   xA1,F
0256:  BZ    027C
....................          {     
....................             delay_us(50); 
0258:  MOVLW  C7
025A:  MOVWF  00
025C:  DECFSZ 00,F
025E:  BRA    025C
0260:  BRA    0262
....................             temp_data <<= 1; 
0262:  BCF    FD8.0
0264:  RLCF   xA3,F
0266:  RLCF   xA4,F
....................             if(SO_pin == TRUE) 
0268:  BSF    F92.1
026A:  BTFSS  F80.1
026C:  BRA    0270
....................             { 
....................                 temp_data |= 1; 
026E:  BSF    xA3.0
....................             } 
....................             output_high(SCK_pin); 
0270:  BCF    F96.0
0272:  BSF    F8D.0
....................             output_low(SCK_pin); 
0274:  BCF    F96.0
0276:  BCF    F8D.0
....................              
....................             clk_pulses--; 
0278:  DECF   xA1,F
027A:  BRA    0254
....................          };    
....................     
....................          //output_high(CS_pin); 
....................             IF (CS == 0){ 
027C:  MOVF   x74,F
027E:  BNZ   0284
....................    output_HIGH(pin_A3); 
0280:  BCF    F92.3
0282:  BSF    F89.3
....................    } 
....................       IF (CS == 1){ 
0284:  DECFSZ x74,W
0286:  BRA    028C
....................    output_HIGH(pin_A5); 
0288:  BCF    F92.5
028A:  BSF    F89.5
....................    } 
....................       IF (CS == 2){ 
028C:  MOVF   x74,W
028E:  SUBLW  02
0290:  BNZ   0296
....................    output_HIGH(pin_E1); 
0292:  BCF    F96.1
0294:  BSF    F8D.1
....................    } 
....................       IF (CS == 3){ 
0296:  MOVF   x74,W
0298:  SUBLW  03
029A:  BNZ   02A0
....................    output_HIGH(pin_E2); 
029C:  BCF    F96.2
029E:  BSF    F8D.2
....................    } 
....................          //temp_data &= 0x7FFF; 
....................           
....................          avg_value += ((unsigned long long)temp_data); 
02A0:  CLRF   02
02A2:  CLRF   03
02A4:  MOVF   xA3,W
02A6:  ADDWF  xA5,F
02A8:  MOVF   xA4,W
02AA:  ADDWFC xA6,F
02AC:  MOVF   02,W
02AE:  ADDWFC xA7,F
02B0:  MOVF   03,W
02B2:  ADDWFC xA8,F
....................           
....................          samples--; 
02B4:  DECF   xA2,F
02B6:  BRA    0224
....................          //delay_ms(10); 
....................    }; 
....................     
....................    temp_data = ((unsigned long)(avg_value >> 4)); 
02B8:  RRCF   xA8,W
02BA:  MOVWF  03
02BC:  RRCF   xA7,W
02BE:  MOVWF  02
02C0:  RRCF   xA6,W
02C2:  MOVWF  01
02C4:  RRCF   xA5,W
02C6:  MOVWF  00
02C8:  RRCF   03,F
02CA:  RRCF   02,F
02CC:  RRCF   01,F
02CE:  RRCF   00,F
02D0:  RRCF   03,F
02D2:  RRCF   02,F
02D4:  RRCF   01,F
02D6:  RRCF   00,F
02D8:  RRCF   03,F
02DA:  RRCF   02,F
02DC:  RRCF   01,F
02DE:  RRCF   00,F
02E0:  MOVLW  0F
02E2:  ANDWF  03,F
02E4:  MOVFF  01,A4
02E8:  MOVFF  00,A3
....................     
....................    if((temp_data & 0x04) == close_contact) 
02EC:  MOVF   xA3,W
02EE:  ANDLW  04
02F0:  MOVWF  xA9
02F2:  CLRF   xAA
02F4:  MOVF   xA9,F
02F6:  BNZ   0328
02F8:  MOVF   xAA,F
02FA:  BNZ   0328
....................    { 
....................       *ADC_data = (temp_data >> 3); 
02FC:  MOVFF  9F,FE9
0300:  MOVFF  A0,FEA
0304:  RRCF   xA4,W
0306:  MOVWF  03
0308:  RRCF   xA3,W
030A:  MOVWF  02
030C:  RRCF   03,F
030E:  RRCF   02,F
0310:  RRCF   03,F
0312:  RRCF   02,F
0314:  MOVLW  1F
0316:  ANDWF  03,F
0318:  MOVFF  02,FEF
031C:  MOVFF  03,FEC
....................       return close_contact; 
0320:  MOVLW  00
0322:  MOVWF  01
0324:  BRA    033E
....................    } 
0326:  BRA    033E
....................     
....................    else 
....................    { 
....................       *ADC_data = (count_max + 1); 
0328:  MOVFF  9F,FE9
032C:  MOVFF  A0,FEA
0330:  MOVLW  10
0332:  MOVWF  FEC
0334:  MOVF   FED,F
0336:  MOVLW  01
0338:  MOVWF  FEF
....................       return open_contact; 
033A:  MOVLW  04
033C:  MOVWF  01
....................    } 
033E:  GOTO   084C (RETURN)
....................     
.................... } 
....................  
....................  
.................... float MAX6675_get_T(unsigned long ADC_value, unsigned char T_unit) 
*
06D4:  CLRF   xA5
06D6:  CLRF   xA4
06D8:  CLRF   xA3
06DA:  CLRF   xA2
.................... { 
....................    float tmp = 0.0; 
....................     
....................    tmp = (ADC_value * scalar_deg_C); 
06DC:  MOVFF  A0,A7
06E0:  MOVFF  9F,A6
06E4:  RCALL  0342
06E6:  MOVFF  03,A9
06EA:  MOVFF  02,A8
06EE:  MOVFF  01,A7
06F2:  MOVFF  00,A6
06F6:  CLRF   xAD
06F8:  CLRF   xAC
06FA:  CLRF   xAB
06FC:  MOVLW  7D
06FE:  MOVWF  xAA
0700:  RCALL  0378
0702:  MOVFF  03,A5
0706:  MOVFF  02,A4
070A:  MOVFF  01,A3
070E:  MOVFF  00,A2
....................     
....................    switch(T_unit) 
0712:  MOVF   xA1,W
0714:  XORLW  01
0716:  BZ    071E
0718:  XORLW  03
071A:  BZ    077C
071C:  BRA    07B0
....................    { 
....................       case deg_F: 
....................       { 
....................          tmp *= scalar_deg_F_1; 
071E:  MOVFF  A5,A9
0722:  MOVFF  A4,A8
0726:  MOVFF  A3,A7
072A:  MOVFF  A2,A6
072E:  MOVLW  66
0730:  MOVWF  xAD
0732:  MOVWF  xAC
0734:  MOVWF  xAB
0736:  MOVLW  7F
0738:  MOVWF  xAA
073A:  RCALL  0378
073C:  MOVFF  03,A5
0740:  MOVFF  02,A4
0744:  MOVFF  01,A3
0748:  MOVFF  00,A2
....................          tmp += scalar_deg_F_2; 
074C:  BCF    FD8.1
074E:  MOVFF  A5,A9
0752:  MOVFF  A4,A8
0756:  MOVFF  A3,A7
075A:  MOVFF  A2,A6
075E:  CLRF   xAD
0760:  CLRF   xAC
0762:  CLRF   xAB
0764:  MOVLW  84
0766:  MOVWF  xAA
0768:  RCALL  046A
076A:  MOVFF  03,A5
076E:  MOVFF  02,A4
0772:  MOVFF  01,A3
0776:  MOVFF  00,A2
....................          break; 
077A:  BRA    07B0
....................       } 
....................       case tmp_K: 
....................       { 
....................         tmp += scalar_tmp_K; 
077C:  BCF    FD8.1
077E:  MOVFF  A5,A9
0782:  MOVFF  A4,A8
0786:  MOVFF  A3,A7
078A:  MOVFF  A2,A6
078E:  CLRF   xAD
0790:  MOVLW  80
0792:  MOVWF  xAC
0794:  MOVLW  08
0796:  MOVWF  xAB
0798:  MOVLW  87
079A:  MOVWF  xAA
079C:  RCALL  046A
079E:  MOVFF  03,A5
07A2:  MOVFF  02,A4
07A6:  MOVFF  01,A3
07AA:  MOVFF  00,A2
....................         break; 
07AE:  BRA    07B0
....................       } 
....................       default: 
....................       { 
....................         break; 
....................       } 
....................    } 
....................    return tmp; 
07B0:  MOVFF  A2,00
07B4:  MOVFF  A3,01
07B8:  MOVFF  A4,02
07BC:  MOVFF  A5,03
07C0:  GOTO   0860 (RETURN)
.................... } 
....................  
.................... const unsigned char degree_symbol[8]=  
.................... { 
....................    0x00, 0x06, 0x09, 0x09, 0x06, 0x00, 0x00, 0x00 
.................... };  
....................    unsigned char unit = deg_C; 
....................    unsigned char state = close_contact; 
....................    //unsigned long ti = 0x0000; 
....................    int16 ti = 0x0000; 
....................    float tf = 0.0; 
....................     
....................  
.................... #include<Adquirir_Datos.c> 
....................  
....................       
....................  Void Adquirir(){       
....................  
.................... DISABLE_interrupts(INT_TIMER1);  
*
083A:  BCF    F9D.0
.................... DISABLE_interrupts(global); 
083C:  BCF    FF2.6
083E:  BCF    FF2.7
0840:  BTFSC  FF2.7
0842:  BRA    083E
....................                            //MODULO TERMOCUPLA SPI  
....................                             
....................                            state = MAX6657_get_ADC(&ti); 
0844:  CLRF   xA0
0846:  MOVLW  77
0848:  MOVWF  x9F
084A:  BRA    0212
084C:  MOVFF  01,76
....................                            unit = deg_C; 
0850:  CLRF   x75
....................                            tf = MAX6675_get_T(ti, unit); 
0852:  MOVFF  78,A0
0856:  MOVFF  77,9F
085A:  MOVFF  75,A1
085E:  BRA    06D4
0860:  MOVFF  03,7C
0864:  MOVFF  02,7B
0868:  MOVFF  01,7A
086C:  MOVFF  00,79
....................                             
....................                            IF (CS==0){ 
0870:  MOVF   x74,F
0872:  BNZ   0884
....................                            //delay_ms(100); 
....................                            Temp_Z1=tf;} 
0874:  MOVFF  7C,32
0878:  MOVFF  7B,31
087C:  MOVFF  7A,30
0880:  MOVFF  79,2F
....................                             
....................                            IF (CS==1){ 
0884:  DECFSZ x74,W
0886:  BRA    0898
....................                            //delay_ms(100); 
....................                            Temp_Z2=tf;} 
0888:  MOVFF  7C,36
088C:  MOVFF  7B,35
0890:  MOVFF  7A,34
0894:  MOVFF  79,33
....................                             
....................                            IF (CS==2){ 
0898:  MOVF   x74,W
089A:  SUBLW  02
089C:  BNZ   08AE
....................                            //delay_ms(100); 
....................                            Temp_Z3=tf;} 
089E:  MOVFF  7C,3A
08A2:  MOVFF  7B,39
08A6:  MOVFF  7A,38
08AA:  MOVFF  79,37
....................                             
....................                            IF (CS==3){ 
08AE:  MOVF   x74,W
08B0:  SUBLW  03
08B2:  BNZ   08C4
....................                            //delay_ms(100); 
....................                            Temp_Z4=tf;} 
08B4:  MOVFF  7C,3E
08B8:  MOVFF  7B,3D
08BC:  MOVFF  7A,3C
08C0:  MOVFF  79,3B
....................                             
.................... enable_interrupts(INT_TIMER1);  
08C4:  BSF    F9D.0
.................... enable_interrupts(global); 
08C6:  MOVLW  C0
08C8:  IORWF  FF2,F
....................                    
....................    IF (Temp_Z3 < SP_Z3) OUTPUT_HIGH(RESISTENCIA_Z3); 
08CA:  MOVFF  4A,A7
08CE:  MOVFF  49,A6
08D2:  RCALL  0342
08D4:  MOVFF  3A,A2
08D8:  MOVFF  39,A1
08DC:  MOVFF  38,A0
08E0:  MOVFF  37,9F
08E4:  MOVFF  03,A6
08E8:  MOVFF  02,A5
08EC:  MOVFF  01,A4
08F0:  MOVFF  00,A3
08F4:  RCALL  07C4
08F6:  BNC   08FE
08F8:  BCF    F95.0
08FA:  BSF    F8C.0
08FC:  BRA    0902
....................    ELSE OUTPUT_LOW(RESISTENCIA_Z3); 
08FE:  BCF    F95.0
0900:  BCF    F8C.0
....................    IF (Temp_Z4 < SP_Z4) OUTPUT_HIGH(RESISTENCIA_Z4); 
0902:  MOVFF  4C,A7
0906:  MOVFF  4B,A6
090A:  RCALL  0342
090C:  MOVFF  3E,A2
0910:  MOVFF  3D,A1
0914:  MOVFF  3C,A0
0918:  MOVFF  3B,9F
091C:  MOVFF  03,A6
0920:  MOVFF  02,A5
0924:  MOVFF  01,A4
0928:  MOVFF  00,A3
092C:  RCALL  07C4
092E:  BNC   0936
0930:  BCF    F94.1
0932:  BSF    F8B.1
0934:  BRA    093A
....................    ELSE OUTPUT_LOW(RESISTENCIA_Z4); 
0936:  BCF    F94.1
0938:  BCF    F8B.1
....................    IF (Temp_Z2 < SP_Z2) OUTPUT_HIGH(RESISTENCIA_Z2); 
093A:  MOVFF  48,A7
093E:  MOVFF  47,A6
0942:  RCALL  0342
0944:  MOVFF  36,A2
0948:  MOVFF  35,A1
094C:  MOVFF  34,A0
0950:  MOVFF  33,9F
0954:  MOVFF  03,A6
0958:  MOVFF  02,A5
095C:  MOVFF  01,A4
0960:  MOVFF  00,A3
0964:  RCALL  07C4
0966:  BNC   096E
0968:  BCF    F95.6
096A:  BSF    F8C.6
096C:  BRA    0972
....................    ELSE OUTPUT_LOW(RESISTENCIA_Z2); 
096E:  BCF    F95.6
0970:  BCF    F8C.6
....................    IF (Temp_Z1 < SP_Z1) OUTPUT_HIGH(RESISTENCIA_Z1); 
0972:  MOVFF  46,A7
0976:  MOVFF  45,A6
097A:  RCALL  0342
097C:  MOVFF  32,A2
0980:  MOVFF  31,A1
0984:  MOVFF  30,A0
0988:  MOVFF  2F,9F
098C:  MOVFF  03,A6
0990:  MOVFF  02,A5
0994:  MOVFF  01,A4
0998:  MOVFF  00,A3
099C:  RCALL  07C4
099E:  BNC   09A6
09A0:  BCF    F95.5
09A2:  BSF    F8C.5
09A4:  BRA    09AA
....................    ELSE OUTPUT_LOW(RESISTENCIA_Z1);  
09A6:  BCF    F95.5
09A8:  BCF    F8C.5
09AA:  GOTO   09CE (RETURN)
....................  } 
....................  
....................  
.................... INT16 CONTA=0; 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //MODULO TERMOCUPLA SPI 
.................... void setup(); 
.................... void lcd_load_symbols(); 
.................... //int8 conta=0; 
.................... /////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //TIMER1 PARA LEER MODULOS TERMOCUPLAS 
....................  
.................... #INT_TIMER1 
.................... void timer1_isr(void) 
.................... { 
....................    DISABLE_interrupts(INT_TIMER1);               // Enable Timer1 interrupt; 
09AE:  BCF    F9D.0
....................    conta ++; 
09B0:  INCF   x7D,F
09B2:  BTFSC  FD8.2
09B4:  INCF   x7E,F
....................    if(conta==10){ 
09B6:  MOVF   x7D,W
09B8:  SUBLW  0A
09BA:  BNZ   09D2
09BC:  MOVF   x7E,F
09BE:  BNZ   09D2
....................    conta=0;       
09C0:  CLRF   x7E
09C2:  CLRF   x7D
....................    CS=0; 
09C4:  CLRF   x74
....................    WHILE (CS< 4){ 
09C6:  MOVF   x74,W
09C8:  SUBLW  03
09CA:  BNC   09D2
....................    Adquirir();/////////////////////////////////////////////////////////////////////////////////////////////////// 
09CC:  BRA    083A
....................    CS++; 
09CE:  INCF   x74,F
09D0:  BRA    09C6
....................    }     
....................    }  
....................    clear_interrupt(INT_TIMER1); 
09D2:  BCF    F9E.0
....................    set_timer1(3036); 
09D4:  MOVLW  0B
09D6:  MOVWF  FCF
09D8:  MOVLW  DC
09DA:  MOVWF  FCE
....................    enable_interrupts(INT_TIMER1);               // Enable Timer1 interrupt; 
09DC:  BSF    F9D.0
09DE:  BCF    F9E.0
09E0:  GOTO   0054
.................... } 
.................... /////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //Reincipal 
.................... /////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... void main() {  
*
28A6:  CLRF   FF8
28A8:  BCF    FD0.7
28AA:  BSF    07.7
28AC:  CLRF   1A
28AE:  CLRF   19
28B0:  CLRF   18
28B2:  CLRF   17
28B4:  CLRF   1E
28B6:  CLRF   1D
28B8:  CLRF   1C
28BA:  CLRF   1B
28BC:  CLRF   22
28BE:  CLRF   21
28C0:  CLRF   20
28C2:  CLRF   1F
28C4:  CLRF   26
28C6:  CLRF   25
28C8:  CLRF   24
28CA:  CLRF   23
28CC:  CLRF   2A
28CE:  CLRF   29
28D0:  CLRF   28
28D2:  CLRF   27
28D4:  CLRF   2E
28D6:  CLRF   2D
28D8:  CLRF   2C
28DA:  CLRF   2B
28DC:  CLRF   46
28DE:  CLRF   45
28E0:  CLRF   48
28E2:  CLRF   47
28E4:  CLRF   4A
28E6:  CLRF   49
28E8:  CLRF   4C
28EA:  CLRF   4B
28EC:  CLRF   x69
28EE:  CLRF   x6A
28F0:  MOVLW  01
28F2:  MOVWF  x6B
28F4:  CLRF   x6C
28F6:  CLRF   x75
28F8:  CLRF   x76
28FA:  CLRF   x78
28FC:  CLRF   x77
28FE:  CLRF   x7C
2900:  CLRF   x7B
2902:  CLRF   x7A
2904:  CLRF   x79
2906:  CLRF   x7E
2908:  CLRF   x7D
290A:  MOVF   FC1,W
290C:  ANDLW  C0
290E:  IORLW  0F
2910:  MOVWF  FC1
2912:  MOVLW  07
2914:  MOVWF  FB4
2916:  CLRF   x6E
2918:  CLRF   x6F
.................... /////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //TIMER1 
....................    setup_timer_1 ( T1_INTERNAL | T1_DIV_BY_8 ); // Internal clock and prescaler 8 
291A:  MOVLW  B5
291C:  MOVWF  FCD
....................    set_timer1(3036);                            // Preload value 
291E:  MOVLW  0B
2920:  MOVWF  FCF
2922:  MOVLW  DC
2924:  MOVWF  FCE
....................    clear_interrupt(INT_TIMER1);                 // Clear Timer1 interrupt flag bit 
2926:  BCF    F9E.0
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //MODULO TERMOCUPLA 
....................    setup(); 
2928:  GOTO   0A56
.................... /////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... INT16 key=0; 
292C:  CLRF   x80
292E:  CLRF   x7F
....................   
....................    set_tris_a (0b00000011); 
2930:  MOVLW  03
2932:  MOVWF  F92
....................    set_tris_b (0b00000000); 
2934:  MOVLW  00
2936:  MOVWF  F93
....................    set_tris_c (0b00000000); //EN PROTEUS(0b01111011);// EN REAL (0b00000000); 
2938:  MOVWF  F94
....................    set_tris_d (0b00000000); 
293A:  MOVWF  F95
....................    set_tris_e (0b00001000); 
293C:  MOVLW  08
293E:  MOVWF  F96
....................     
....................    SPPCON = 0; 
2940:  CLRF   F65
....................     
....................    PORTA = 0; 
2942:  CLRF   F80
....................    PORTB = 0; 
2944:  CLRF   F81
....................    PORTC = 0; 
2946:  CLRF   F82
....................    PORTD = 0; 
2948:  CLRF   F83
....................    
....................    OUTPUT_low(BEEP); 
294A:  BCF    F93.7
294C:  BCF    F8A.7
....................    lcd_init(); 
294E:  GOTO   0BBE
....................    lcd_gotoxy(1,1); 
2952:  MOVLW  01
2954:  MOVWF  x90
2956:  MOVWF  x91
2958:  CALL   0C1C
....................    lcd_putc("H2-Tec"); 
295C:  MOVLW  E4
295E:  MOVWF  FF6
2960:  MOVLW  09
2962:  MOVWF  FF7
2964:  CALL   0CA4
....................    lcd_gotoxy(1,3); 
2968:  MOVLW  01
296A:  MOVWF  x90
296C:  MOVLW  03
296E:  MOVWF  x91
2970:  CALL   0C1C
....................    lcd_putc("Sistema de extrusion"); 
2974:  MOVLW  EC
2976:  MOVWF  FF6
2978:  MOVLW  09
297A:  MOVWF  FF7
297C:  CALL   0CA4
....................    lcd_gotoxy(1,4); 
2980:  MOVLW  01
2982:  MOVWF  x90
2984:  MOVLW  04
2986:  MOVWF  x91
2988:  CALL   0C1C
....................    lcd_putc("Version 1.0"); 
298C:  MOVLW  02
298E:  MOVWF  FF6
2990:  MOVLW  0A
2992:  MOVWF  FF7
2994:  CALL   0CA4
....................    Beep_largo();   
2998:  GOTO   0CC4
....................    lcd_putc("\f");   
299C:  MOVLW  0E
299E:  MOVWF  FF6
29A0:  MOVLW  0A
29A2:  MOVWF  FF7
29A4:  CALL   0CA4
....................     
....................    //RECUPERA LOS VALORES DE SET POINT 
....................    SP_Z4 = Leer_EEPROM(DIR_SPZ4); 
29A8:  CLRF   x82
29AA:  CLRF   x81
29AC:  CALL   0D04
29B0:  MOVFF  02,4C
29B4:  MOVFF  01,4B
....................    SP_Z3 = Leer_EEPROM(DIR_SPZ3); 
29B8:  CLRF   x82
29BA:  MOVLW  02
29BC:  MOVWF  x81
29BE:  CALL   0D04
29C2:  MOVFF  02,4A
29C6:  MOVFF  01,49
....................    SP_Z2 = Leer_EEPROM(DIR_SPZ2);   
29CA:  CLRF   x82
29CC:  MOVLW  04
29CE:  MOVWF  x81
29D0:  CALL   0D04
29D4:  MOVFF  02,48
29D8:  MOVFF  01,47
....................    SP_Z1 = Leer_EEPROM(DIR_SPZ1); 
29DC:  CLRF   x82
29DE:  MOVLW  06
29E0:  MOVWF  x81
29E2:  CALL   0D04
29E6:  MOVFF  02,46
29EA:  MOVFF  01,45
....................    SP_I_MOT = Leer_EEPROM(DIR_SP_I_MOT); 
29EE:  CLRF   x82
29F0:  MOVLW  08
29F2:  MOVWF  x81
29F4:  CALL   0D04
29F8:  MOVFF  02,4E
29FC:  MOVFF  01,4D
....................    SP_T_MOT = Leer_EEPROM(DIR_SP_T_MOT); 
2A00:  CLRF   x82
2A02:  MOVLW  0A
2A04:  MOVWF  x81
2A06:  CALL   0D04
2A0A:  MOVFF  02,50
2A0E:  MOVFF  01,4F
....................    OFFSET_Z1 = Leer_EEPROM(DIR_OFF_Z1); 
2A12:  CLRF   x82
2A14:  MOVLW  14
2A16:  MOVWF  x81
2A18:  CALL   0D04
2A1C:  MOVFF  02,52
2A20:  MOVFF  01,51
....................    OFFSET_Z2 = Leer_EEPROM(DIR_OFF_Z2); 
2A24:  CLRF   x82
2A26:  MOVLW  16
2A28:  MOVWF  x81
2A2A:  CALL   0D04
2A2E:  MOVFF  02,54
2A32:  MOVFF  01,53
....................    OFFSET_Z3 = Leer_EEPROM(DIR_OFF_Z3); 
2A36:  CLRF   x82
2A38:  MOVLW  18
2A3A:  MOVWF  x81
2A3C:  CALL   0D04
2A40:  MOVFF  02,56
2A44:  MOVFF  01,55
....................    OFFSET_Z4 = Leer_EEPROM(DIR_OFF_Z4); 
2A48:  CLRF   x82
2A4A:  MOVLW  1A
2A4C:  MOVWF  x81
2A4E:  CALL   0D04
2A52:  MOVFF  02,58
2A56:  MOVFF  01,57
....................    OFFSET_MOT = Leer_EEPROM(DIR_OFF_MOT); 
2A5A:  CLRF   x82
2A5C:  MOVLW  20
2A5E:  MOVWF  x81
2A60:  CALL   0D04
2A64:  MOVFF  02,5C
2A68:  MOVFF  01,5B
....................    OFFSET_AMB = Leer_EEPROM(DIR_OFF_AMB); 
2A6C:  CLRF   x82
2A6E:  MOVLW  22
2A70:  MOVWF  x81
2A72:  CALL   0D04
2A76:  MOVFF  02,5A
2A7A:  MOVFF  01,59
....................    MAX_Z1 = Leer_EEPROM(DIR_MAX_Z1); 
2A7E:  CLRF   x82
2A80:  MOVLW  0C
2A82:  MOVWF  x81
2A84:  CALL   0D04
2A88:  MOVFF  02,5E
2A8C:  MOVFF  01,5D
....................    MAX_Z2 = Leer_EEPROM(DIR_MAX_Z2); 
2A90:  CLRF   x82
2A92:  MOVLW  0E
2A94:  MOVWF  x81
2A96:  CALL   0D04
2A9A:  MOVFF  02,60
2A9E:  MOVFF  01,5F
....................    MAX_Z3 = Leer_EEPROM(DIR_MAX_Z3); 
2AA2:  CLRF   x82
2AA4:  MOVLW  10
2AA6:  MOVWF  x81
2AA8:  CALL   0D04
2AAC:  MOVFF  02,62
2AB0:  MOVFF  01,61
....................    MAX_Z4 = Leer_EEPROM(DIR_MAX_Z4); 
2AB4:  CLRF   x82
2AB6:  MOVLW  12
2AB8:  MOVWF  x81
2ABA:  CALL   0D04
2ABE:  MOVFF  02,64
2AC2:  MOVFF  01,63
....................    MAX_MOT = Leer_EEPROM(DIR_MAX_MOT); 
2AC6:  CLRF   x82
2AC8:  MOVLW  1C
2ACA:  MOVWF  x81
2ACC:  CALL   0D04
2AD0:  MOVFF  02,68
2AD4:  MOVFF  01,67
....................    MAX_AMB = Leer_EEPROM(DIR_MAX_AMB); 
2AD8:  CLRF   x82
2ADA:  MOVLW  1E
2ADC:  MOVWF  x81
2ADE:  CALL   0D04
2AE2:  MOVFF  02,66
2AE6:  MOVFF  01,65
....................     
....................     
....................    enable_interrupts(INT_TIMER1);               // Enable Timer1 interrupt; 
2AEA:  BSF    F9D.0
....................    enable_interrupts(global); 
2AEC:  MOVLW  C0
2AEE:  IORWF  FF2,F
....................    
.................... /////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //Loop infinito 
.................... /////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................    while(TRUE){ 
....................     
....................    delay_ms(50); 
2AF0:  MOVLW  32
2AF2:  MOVWF  x90
2AF4:  CALL   0AA6
....................                        
....................    /////////  Pantallas    ///////// 
....................    if (Pantalla_actual == 0){ 
2AF8:  MOVF   x69,F
2AFA:  BNZ   2B02
....................       pantalla_0_fija(); 
2AFC:  CALL   10B8
....................    }  
2B00:  BRA    2B22
....................    else if (Pantalla_actual == 1) 
2B02:  DECFSZ x69,W
2B04:  BRA    2B0C
....................       pantalla_1_fija(); 
2B06:  CALL   1448
2B0A:  BRA    2B22
....................    
....................    else if (Pantalla_actual == 2) 
2B0C:  MOVF   x69,W
2B0E:  SUBLW  02
2B10:  BNZ   2B18
....................       pantalla_2_fija(); 
2B12:  CALL   167A
2B16:  BRA    2B22
....................    else if (Pantalla_actual == 3) 
2B18:  MOVF   x69,W
2B1A:  SUBLW  03
2B1C:  BNZ   2B22
....................       pantalla_3_fija(); 
2B1E:  CALL   194A
....................     
....................    key=leer_botones(); 
2B22:  GOTO   1AB0
2B26:  CLRF   x80
2B28:  MOVFF  01,7F
....................    if(flag_programacion==0){ 
2B2C:  MOVF   x6A,F
2B2E:  BNZ   2BA4
....................       if(key==SW_ARRIBA) 
2B30:  MOVF   x7F,W
2B32:  SUBLW  03
2B34:  BNZ   2B44
2B36:  MOVF   x80,F
2B38:  BNZ   2B44
....................             Cambiar_pantalla(SW_ARRIBA); 
2B3A:  MOVLW  03
2B3C:  MOVWF  x81
2B3E:  CALL   1BCC
2B42:  BRA    2BA2
....................       else if(key==SW_ABAJO) 
2B44:  MOVF   x7F,W
2B46:  SUBLW  02
2B48:  BNZ   2B58
2B4A:  MOVF   x80,F
2B4C:  BNZ   2B58
....................             Cambiar_pantalla(SW_ABAJO); 
2B4E:  MOVLW  02
2B50:  MOVWF  x81
2B52:  CALL   1BCC
2B56:  BRA    2BA2
....................       else if(key==SW_CENTRO){ 
2B58:  DECFSZ x7F,W
2B5A:  BRA    2BA2
2B5C:  MOVF   x80,F
2B5E:  BNZ   2BA2
....................             flag_programacion=1; 
2B60:  MOVLW  01
2B62:  MOVWF  x6A
....................              lcd_putc("\f"); 
2B64:  MOVLW  10
2B66:  MOVWF  FF6
2B68:  MOVLW  0A
2B6A:  MOVWF  FF7
2B6C:  CALL   0CA4
....................        lcd_gotoxy(2,2); 
2B70:  MOVLW  02
2B72:  MOVWF  x90
2B74:  MOVWF  x91
2B76:  CALL   0C1C
....................     printf(lcd_putc,"MODO PROGRAMACION"); 
2B7A:  MOVLW  12
2B7C:  MOVWF  FF6
2B7E:  MOVLW  0A
2B80:  MOVWF  FF7
2B82:  CALL   0CA4
....................     delay_ms(500); 
2B86:  MOVLW  02
2B88:  MOVWF  x81
2B8A:  MOVLW  FA
2B8C:  MOVWF  x90
2B8E:  CALL   0AA6
2B92:  DECFSZ x81,F
2B94:  BRA    2B8A
....................     lcd_putc("\f"); 
2B96:  MOVLW  24
2B98:  MOVWF  FF6
2B9A:  MOVLW  0A
2B9C:  MOVWF  FF7
2B9E:  CALL   0CA4
....................       } 
....................    } 
2BA2:  BRA    2BB4
....................    else if(flag_programacion==1) 
2BA4:  DECFSZ x6A,W
2BA6:  BRA    2BB4
....................       Modo_programacion1(key); 
2BA8:  MOVFF  80,82
2BAC:  MOVFF  7F,81
2BB0:  GOTO   229E
2BB4:  BRA    2AF0
....................       
....................    }  //cierro while(1) 
.................... }     //cierro main 
....................  
2BB6:  SLEEP 
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //MODULO TERMOCUPLA SPI 
.................... void setup() 
.................... { 
....................    //disable_interrupts(global); 
....................    setup_SPI(SPI_DISABLED | SPI_SS_DISABLED); 
*
0A56:  BCF    FC6.5
0A58:  BCF    F94.7
0A5A:  BSF    F93.0
0A5C:  BCF    F93.1
0A5E:  MOVLW  01
0A60:  MOVWF  FC6
0A62:  MOVLW  00
0A64:  MOVWF  FC7
....................    setup_comparator(NC_NC_NC_NC); 
0A66:  MOVLW  07
0A68:  MOVWF  FB4
0A6A:  MOVF   F92,W
0A6C:  MOVWF  F92
0A6E:  MOVLW  27
0A70:  MOVWF  00
0A72:  DECFSZ 00,F
0A74:  BRA    0A72
0A76:  BRA    0A78
0A78:  MOVF   FB4,W
0A7A:  BCF    FA1.6
....................    setup_adc(ADC_OFF); 
0A7C:  BCF    FC2.0
....................    setup_adc_ports(no_analogs); 
0A7E:  MOVF   FC1,W
0A80:  ANDLW  C0
0A82:  IORLW  0F
0A84:  MOVWF  FC1
....................    setup_psp(FALSE); 
0A86:  BCF    F96.4
....................    setup_CCP1(CCP_OFF); 
0A88:  MOVLW  F0
0A8A:  ANDWF  FBD,F
....................    setup_CCP2(CCP_OFF); 
0A8C:  ANDWF  FBA,F
....................    setup_timer_0(T0_INTERNAL | T0_DIV_256 | T0_8_BIT); 
0A8E:  MOVLW  C7
0A90:  MOVWF  FD5
....................    set_timer0(0x00); 
0A92:  CLRF   FD7
0A94:  CLRF   FD6
....................    setup_timer_2(T2_DISABLED, 0xFF, 1); 
0A96:  MOVLW  00
0A98:  MOVWF  FCA
0A9A:  MOVLW  FF
0A9C:  MOVWF  FCB
....................    set_timer2(0x00); 
0A9E:  CLRF   FCC
....................     
....................    MAX6675_init();   
0AA0:  BRA    0A26
0AA2:  GOTO   292C (RETURN)
.................... } 
....................  
.................... void lcd_load_symbols()   
.................... { 
....................    unsigned char i = 0;      
....................     
....................    lcd_send_byte(0, 0x40);  
....................     
....................    for(i = 0; i < 8; i++) 
....................    { 
....................         lcd_send_byte(1, degree_symbol[i]); 
....................    } 
....................     
....................    lcd_send_byte(0, 0x80); 
.................... }  
.................... /////////////////////////////////////////////////////////////////////////////////////////////// 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
